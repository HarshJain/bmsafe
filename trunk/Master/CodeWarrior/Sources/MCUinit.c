/*
** ###################################################################
**     This code is generated by the Device Initialization Tool.
**     It is overwritten during code generation.
**     USER MODIFICATION ARE PRESERVED ONLY INSIDE INTERRUPT SERVICE ROUTINES
**     OR EXPLICITLY MARKED SECTIONS
**
**     Project   : Master
**     Processor : MC9S12XEP100MAL
**     Version   : Component 01.003, Driver 01.05, CPU db: 3.00.033
**     Datasheet : MC9S12XEP100 Rev. 1.19 12/2008
**     Date/Time : 2011-04-12, 16:06
**     Abstract  :
**         This module contains device initialization code 
**         for selected on-chip peripherals.
**     Contents  :
**         Function "MCU_init" initializes selected peripherals
**
**     Copyright : 1997 - 2010 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################
*/
/* MODULE MCUinit */

#include <MC9S12XEP100.h>              /* I/O map for MC9S12XEP100MAL */
#include "MCUinit.h"

/* Standard ANSI C types */
#ifndef int8_t
typedef signed char int8_t;
#endif
#ifndef int16_t
typedef signed int   int16_t;
#endif
#ifndef int32_t
typedef signed long int    int32_t;
#endif

#ifndef uint8_t
typedef unsigned char       uint8_t;
#endif
#ifndef uint16_t
typedef unsigned int  uint16_t;
#endif
#ifndef uint32_t
typedef unsigned long int   uint32_t;
#endif

#define CGM_DELAY  1023U

/* User declarations and definitions */
/*   Code, declarations and definitions here will be preserved during code generation */

#include <hidef.h>            /* common defines and macros */
#include "derivative.h"      /* derivative-specific definitions */
#include "terminal_code.h"
#include "parameters.h"
#include "can.h"
#include "defines.h"
#include "termio.h"
#include "relays.h"
#include <stdio.h>


extern unsigned int gCellVolt[N_MOD_MAX][N_CELL_SLV_MAX];
extern int gCellTemp[N_MOD_MAX][N_CELL_SLV_MAX];

extern long int gCurrentMsr1[N_CURR_MSR];
extern long int gCurrentMsr2[N_CURR_MSR];
extern long int* gCurrentMsr;
extern unsigned int gSlaveComState;
extern int gErrorBits;
extern unsigned int gSlaveEquiStatus; 
extern char gIgnition;
extern char gSOCready;
extern unsigned char gFirstADCdone;
extern unsigned char gMode;
extern char gRelaysClosed;
extern char gActivEqui;

extern unsigned char gbrusa1[7];
extern unsigned char gbrusa2[7];

//variable de status
extern unsigned int lastSOC;
extern unsigned int presSOC;
extern unsigned int gFaultMeasure;  
extern unsigned int glowestV;
extern unsigned int glowestT;
extern unsigned int gmaxV;
extern unsigned int gmaxT;
extern long int gLastCurrent;
extern unsigned int gi;

/* End of user declarations and definitions */

extern void near _Startup(void);

#pragma CODE_SEG __NEAR_SEG NON_BANKED

static void MCU_init_reset(void);
/*
** ===================================================================
**     Method      :  MCU_init_reset (component MC9S12XEP100_112)
**
**     Description :
**         Device initialization code for after reset initialization.
** ===================================================================
*/
static void MCU_init_reset(void)
{

  /*  Initialization of memory configuration */
  /* MMCCTL1: TGMRAMON=0,EEEIFRON=0,PGMIFRON=0,RAMHM=0,EROMON=0,ROMHM=0,ROMON=1 */
  MMCCTL1 = 1U;                                      
  /* DIRECT: DP15=0,DP14=0,DP13=0,DP12=0,DP11=0,DP10=0,DP9=0,DP8=0 */
  DIRECT = 0U;                                      
  /* IVBR: IVB_ADDR=255 */
  IVBR = 255U;                                      
  /* ECLKCTL: NECLK=1,NCLKX2=1,DIV16=0,EDIV4=0,EDIV3=0,EDIV2=0,EDIV1=0,EDIV0=0 */
  ECLKCTL = 192U;                                      
  /* Jump to the default entry point */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm jmp _Startup;
  /*lint -restore Enable MISRA rule (1.1) checking. */
} /*MCU_init*/

#pragma CODE_SEG DEFAULT
#pragma MESSAGE DISABLE C12056



/*
** ===================================================================
**     Method      :  MCU_init (component MC9S12XEP100_112)
**
**     Description :
**         Device initialization code for selected peripherals.
** ===================================================================
*/
void MCU_init(void)
{

  /* ### MC9S12XEP100_112 "Cpu" init code ... */
  /*  PE initialization code after reset */
  /*  System clock initialization */
  /* CLKSEL: PLLSEL=0,PSTP=0,XCLKS=0,PLLWAI=0,RTIWAI=0,COPWAI=0 */
  CLKSEL = 0U;                         /* Select clock source from XTAL and set bits in CLKSEL reg. */
  /* PLLCTL: CME=1,PLLON=0,FM1=0,FM0=0,FSTWKP=0,PRE=0,PCE=0,SCME=1 */
  PLLCTL = 129U;                       /* Disable the PLL */
  /* VREGHTCL: VSEL=0,VAE=1,HTEN=0,HTDS=0,HTIE=0,HTIF=0 */
  VREGHTCL = 16U;                                      
  /* Initialization of Memory Protection unit */
  /* MPUSEL: SVSEN=0,SEL=1 */
  MPUSEL = 1U;                         /* Select Descriptor num. 1 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=2 */
  MPUSEL = 2U;                         /* Select Descriptor num. 2 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=3 */
  MPUSEL = 3U;                         /* Select Descriptor num. 3 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=4 */
  MPUSEL = 4U;                         /* Select Descriptor num. 4 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=5 */
  MPUSEL = 5U;                         /* Select Descriptor num. 5 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=6 */
  MPUSEL = 6U;                         /* Select Descriptor num. 6 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=7 */
  MPUSEL = 7U;                         /* Select Descriptor num. 7 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=0,MSTR1=0,MSTR2=0,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 0U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* MPUSEL: SVSEN=0,SEL=0 */
  MPUSEL = 0U;                         /* Select Descriptor num. 0 */
  /* MPUDESC2: LOW_ADDR10=0,LOW_ADDR9=0,LOW_ADDR8=0,LOW_ADDR7=0,LOW_ADDR6=0,LOW_ADDR5=0,LOW_ADDR4=0,LOW_ADDR3=0 */
  MPUDESC2 = 0U;                                      
  /* MPUDESC1: LOW_ADDR18=0,LOW_ADDR17=0,LOW_ADDR16=0,LOW_ADDR15=0,LOW_ADDR14=0,LOW_ADDR13=0,LOW_ADDR12=0,LOW_ADDR11=0 */
  MPUDESC1 = 0U;                                      
  /* MPUDESC0: MSTR0=1,MSTR1=1,MSTR2=1,MSTR3=0,LOW_ADDR22=0,LOW_ADDR21=0,LOW_ADDR20=0,LOW_ADDR19=0 */
  MPUDESC0 = 224U;                                      
  /* MPUDESC5: HIGH_ADDR10=1,HIGH_ADDR9=1,HIGH_ADDR8=1,HIGH_ADDR7=1,HIGH_ADDR6=1,HIGH_ADDR5=1,HIGH_ADDR4=1,HIGH_ADDR3=1 */
  MPUDESC5 = 255U;                                      
  /* MPUDESC4: HIGH_ADDR18=1,HIGH_ADDR17=1,HIGH_ADDR16=1,HIGH_ADDR15=1,HIGH_ADDR14=1,HIGH_ADDR13=1,HIGH_ADDR12=1,HIGH_ADDR11=1 */
  MPUDESC4 = 255U;                                      
  /* MPUDESC3: WP=0,NEX=0,HIGH_ADDR22=1,HIGH_ADDR21=1,HIGH_ADDR20=1,HIGH_ADDR19=1 */
  MPUDESC3 = 15U;                                      
  /* Int. priority initialization */
  /*                                        No. Address Pri XGATE Name            Description */
  INT_CFADDR = 16U;                                      
  INT_CFDATA4 = 1U;                    /*  0x0C  0xFF18   1   no   ivVReserved115  unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x0D  0xFF1A   1   no   ivVReserved114  unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x0E  0xFF1C   1   no   ivVReserved113  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x0F  0xFF1E   1   no   ivVReserved112  unused by PE */
  INT_CFADDR = 32U;                                      
  INT_CFDATA0 = 1U;                    /*  0x10  0xFF20   1   no   ivVReserved111  unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x11  0xFF22   1   no   ivVReserved110  unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x12  0xFF24   1   no   ivVReserved109  unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x13  0xFF26   1   no   ivVReserved108  unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x14  0xFF28   1   no   ivVReserved107  unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x15  0xFF2A   1   no   ivVReserved106  unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x16  0xFF2C   1   no   ivVReserved105  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x17  0xFF2E   1   no   ivVReserved104  unused by PE */
  INT_CFADDR = 48U;                                      
  INT_CFDATA0 = 1U;                    /*  0x18  0xFF30   1   no   ivVReserved103  unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x19  0xFF32   1   no   ivVReserved102  unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x1A  0xFF34   1   no   ivVReserved101  unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x1B  0xFF36   1   no   ivVReserved100  unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x1C  0xFF38   1   no   ivVReserved99   unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x1D  0xFF3A   1   no   ivVReserved98   unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x1E  0xFF3C   1   no   ivVatd1compare  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x1F  0xFF3E   1   no   ivVatd0compare  used by PE */
  INT_CFADDR = 64U;                                      
  INT_CFDATA0 = 1U;                    /*  0x20  0xFF40   1   no   ivVtimpaie      unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x21  0xFF42   1   no   ivVtimpaaovf    unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x22  0xFF44   1   no   ivVtimovf       unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x23  0xFF46   1   no   ivVtimch7       unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x24  0xFF48   1   no   ivVtimch6       unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x25  0xFF4A   1   no   ivVtimch5       unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x26  0xFF4C   1   no   ivVtimch4       unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x27  0xFF4E   1   no   ivVtimch3       unused by PE */
  INT_CFADDR = 80U;                                      
  INT_CFDATA0 = 1U;                    /*  0x28  0xFF50   1   no   ivVtimch2       unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x29  0xFF52   1   no   ivVtimch1       unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x2A  0xFF54   1   no   ivVtimch0       unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x2B  0xFF56   1   no   ivVsci7         unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x2C  0xFF58   1   no   ivVpit7         unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x2D  0xFF5A   1   no   ivVpit6         unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x2E  0xFF5C   1   no   ivVpit5         unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x2F  0xFF5E   1   no   ivVpit4         used by PE */
  INT_CFADDR = 96U;                                      
  INT_CFDATA0 = 1U;                    /*  0x30  0xFF60   1   no   ivVReserved79   unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x31  0xFF62   1   no   ivVReserved78   unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x32  0xFF64   1   no   ivVxst7         unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x33  0xFF66   1   no   ivVxst6         unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x34  0xFF68   1   no   ivVxst5         unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x35  0xFF6A   1   no   ivVxst4         unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x36  0xFF6C   1   no   ivVxst3         unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x37  0xFF6E   1   no   ivVxst2         unused by PE */
  INT_CFADDR = 112U;                                      
  INT_CFDATA0 = 1U;                    /*  0x38  0xFF70   1   no   ivVxst1         unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x39  0xFF72   1   no   ivVxst0         unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x3A  0xFF74   1   no   ivVpit3         used by PE */
  INT_CFDATA3 = 1U;                    /*  0x3B  0xFF76   1   no   ivVpit2         used by PE */
  INT_CFDATA4 = 1U;                    /*  0x3C  0xFF78   1   no   ivVpit1         used by PE */
  INT_CFDATA5 = 1U;                    /*  0x3D  0xFF7A   1   no   ivVpit0         used by PE */
  INT_CFDATA6 = 1U;                    /*  0x3E  0xFF7C   1   -    ivVhti          unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x3F  0xFF7E   1   no   ivVapi          unused by PE */
  INT_CFADDR = 128U;                                      
  INT_CFDATA0 = 1U;                    /*  0x40  0xFF80   1   no   ivVlvi          unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x41  0xFF82   1   no   ivVReserved62   unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x42  0xFF84   1   no   ivVsci5         used by PE */
  INT_CFDATA3 = 1U;                    /*  0x43  0xFF86   1   no   ivVsci4         unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x44  0xFF88   1   no   ivVsci3         unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x45  0xFF8A   1   no   ivVsci2         unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x46  0xFF8C   1   no   ivVpwmesdn      used by PE */
  INT_CFDATA7 = 1U;                    /*  0x47  0xFF8E   1   no   ivVportp        unused by PE */
  INT_CFADDR = 144U;                                      
  INT_CFDATA0 = 1U;                    /*  0x48  0xFF90   1   no   ivVcan4tx       unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x49  0xFF92   1   no   ivVcan4rx       unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x4A  0xFF94   1   no   ivVcan4err      unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x4B  0xFF96   1   no   ivVcan4wkup     unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x4C  0xFF98   1   no   ivVcan3tx       unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x4D  0xFF9A   1   no   ivVcan3rx       unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x4E  0xFF9C   1   no   ivVcan3err      unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x4F  0xFF9E   1   no   ivVcan3wkup     unused by PE */
  INT_CFADDR = 160U;                                      
  INT_CFDATA0 = 1U;                    /*  0x50  0xFFA0   1   no   ivVcan2tx       unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x51  0xFFA2   1   no   ivVcan2rx       unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x52  0xFFA4   1   no   ivVcan2err      unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x53  0xFFA6   1   no   ivVcan2wkup     unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x54  0xFFA8   1   no   ivVcan1tx       used by PE */
  INT_CFDATA5 = 1U;                    /*  0x55  0xFFAA   1   no   ivVcan1rx       used by PE */
  INT_CFDATA6 = 1U;                    /*  0x56  0xFFAC   1   no   ivVcan1err      used by PE */
  INT_CFDATA7 = 1U;                    /*  0x57  0xFFAE   1   no   ivVcan1wkup     used by PE */
  INT_CFADDR = 176U;                                      
  INT_CFDATA0 = 1U;                    /*  0x58  0xFFB0   1   no   ivVcan0tx       used by PE */
  INT_CFDATA1 = 1U;                    /*  0x59  0xFFB2   1   no   ivVcan0rx       used by PE */
  INT_CFDATA2 = 1U;                    /*  0x5A  0xFFB4   1   no   ivVcan0err      used by PE */
  INT_CFDATA3 = 1U;                    /*  0x5B  0xFFB6   1   no   ivVcan0wkup     used by PE */
  INT_CFDATA4 = 1U;                    /*  0x5C  0xFFB8   1   no   ivVflash        unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x5D  0xFFBA   1   no   ivVflashfd      unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x5E  0xFFBC   1   no   ivVspi2         unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x5F  0xFFBE   1   no   ivVspi1         unused by PE */
  INT_CFADDR = 192U;                                      
  INT_CFDATA0 = 1U;                    /*  0x60  0xFFC0   1   no   ivViic0         unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x61  0xFFC2   1   no   ivVsci6         unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x62  0xFFC4   1   no   ivVcrgscm       unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x63  0xFFC6   1   no   ivVcrgplllck    unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x64  0xFFC8   1   no   ivVectpabovf    unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x65  0xFFCA   1   no   ivVectmdcu      unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x66  0xFFCC   1   no   ivVporth        unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x67  0xFFCE   1   no   ivVportj        unused by PE */
  INT_CFADDR = 208U;                                      
  INT_CFDATA0 = 1U;                    /*  0x68  0xFFD0   1   no   ivVatd1         unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x69  0xFFD2   1   no   ivVatd0         used by PE */
  INT_CFDATA2 = 1U;                    /*  0x6A  0xFFD4   1   no   ivVsci1         unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x6B  0xFFD6   1   no   ivVsci0         unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x6C  0xFFD8   1   no   ivVspi0         unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x6D  0xFFDA   1   no   ivVectpaie      unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x6E  0xFFDC   1   no   ivVectpaaovf    unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x6F  0xFFDE   1   no   ivVectovf       unused by PE */
  INT_CFADDR = 224U;                                      
  INT_CFDATA0 = 1U;                    /*  0x70  0xFFE0   1   no   ivVectch7       unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x71  0xFFE2   1   no   ivVectch6       unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x72  0xFFE4   1   no   ivVectch5       unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x73  0xFFE6   1   no   ivVectch4       unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x74  0xFFE8   1   no   ivVectch3       unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x75  0xFFEA   1   no   ivVectch2       unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x76  0xFFEC   1   no   ivVectch1       unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x77  0xFFEE   1   no   ivVectch0       unused by PE */
  INT_CFADDR = 240U;                                      
  INT_CFDATA0 = 1U;                    /*  0x78  0xFFF0   1   no   ivVrti          unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x79  0xFFF2   1   no   ivVirq          unused by PE */
  /* Common initialization of the CPU registers */
  /* PTLRR: PTLRR5=0 */
  PTLRR &= (unsigned char)~(unsigned char)32U;                     
  /* RDRH: RDRH7=0,RDRH6=0,RDRH5=0,RDRH4=0,RDRH3=0,RDRH2=0,RDRH1=0,RDRH0=0 */
  RDRH = 0U;                                      
  /* RDRJ: RDRJ7=0,RDRJ6=0,RDRJ1=0,RDRJ0=0 */
  RDRJ &= (unsigned char)~(unsigned char)195U;                     
  /* MODRR: MODRR1=1,MODRR0=1 */
  MODRR |= (unsigned char)3U;                      
  /* RDRP: RDRP7=0,RDRP6=0,RDRP5=0,RDRP4=0,RDRP3=0,RDRP2=0,RDRP1=0,RDRP0=0 */
  RDRP = 0U;                                      
  /* WOMM: WOMM3=0 */
  WOMM &= (unsigned char)~(unsigned char)8U;                     
  /* RDRM: RDRM7=0,RDRM6=0,RDRM5=0,RDRM4=0,RDRM3=0,RDRM2=0,RDRM1=0,RDRM0=0 */
  RDRM = 0U;                                      
  /* CRGINT: LOCKIE=0,SCMIE=0 */
  CRGINT &= (unsigned char)~(unsigned char)18U;                     
  /* VREGCTRL: LVIE=0 */
  VREGCTRL &= (unsigned char)~(unsigned char)2U;                     
  /* COPCTL: WCOP=0,RSBCK=0,WRTMASK=0,CR2=0,CR1=0,CR0=0 */
  COPCTL = 0U;                                      
  /* RDRIV: RDPK=0,RDPE=0,RDPB=0,RDPA=0 */
  RDRIV &= (unsigned char)~(unsigned char)147U;                     
  /* RDRS: RDRS7=0,RDRS6=0,RDRS5=0,RDRS4=0,RDRS3=0,RDRS2=0,RDRS1=0,RDRS0=0 */
  RDRS = 0U;                                      
  /* RDRT: RDRT7=0,RDRT6=0,RDRT5=0,RDRT4=0,RDRT3=0,RDRT2=0,RDRT1=0,RDRT0=0 */
  RDRT = 0U;                                      
  /* RDR0AD0: RDR0AD07=0,RDR0AD06=0,RDR0AD05=0,RDR0AD04=0,RDR0AD03=0,RDR0AD02=0,RDR0AD01=0,RDR0AD00=0 */
  RDR0AD0 = 0U;                                      
  /* RDR1AD0: RDR1AD07=0,RDR1AD06=0,RDR1AD05=0,RDR1AD04=0,RDR1AD03=0,RDR1AD02=0,RDR1AD01=0,RDR1AD00=0 */
  RDR1AD0 = 0U;                                      
  /* IRQCR: IRQEN=0 */
  IRQCR &= (unsigned char)~(unsigned char)64U;                     
  /* ### Init_SCI init code */
  /* SCI5CR2: TIE=0,TCIE=0,RIE=0,ILIE=0,TE=0,RE=0,RWU=0,SBK=0 */
  SCI5CR2 = 0U;                        /* Disable the SCI5 module */
  (void)(SCI5SR1 == 0);                /* Dummy read of the SCI5SR1 registr to clear flags */
  (void)(SCI5DRL == 0);                /* Dummy read of the SCI5DRL registr to clear flags */
  /* SCI5SR2: AMAP=0,TXPOL=0,RXPOL=0,BRK13=0,TXDIR=0,RAF=0 */
  SCI5SR2 = 0U;                                      
  /* SCI5BD: IREN=0,TNP1=0,TNP0=0,SBR12=0,SBR11=0,SBR10=0,SBR9=0,SBR8=0,SBR7=0,SBR6=0,SBR5=1,SBR4=1,SBR3=0,SBR2=1,SBR1=0,SBR0=0 */
  SCI5BD = 52U;                            
  /* SCI5CR1: LOOPS=0,SCISWAI=0,RSRC=0,M=0,WAKE=0,ILT=0,PE=0,PT=0 */
  SCI5CR1 = 0U;                                      
  /* SCI5SR2: AMAP=1 */
  SCI5SR2 |= (unsigned char)128U;      /* Switch to the alternative register set */
  /* SCI5ASR1: RXEDGIF=1,BERRV=0,BERRIF=1,BKDIF=1 */
  SCI5ASR1 = 131U;                     /* Clear interrupt flags */
  /* SCI5ACR1: RXEDGIE=0,BERRIE=0,BKDIE=0 */
  SCI5ACR1 = 0U;                                      
  /* SCI5ACR2: BERRM1=0,BERRM0=0,BKDFE=0 */
  SCI5ACR2 = 0U;                                      
  /* SCI5SR2: AMAP=0 */
  SCI5SR2 &= (unsigned char)~(unsigned char)128U; /* Switch to the normal register set */
  /* SCI5CR2: TIE=0,TCIE=0,RIE=0,ILIE=0,TE=1,RE=1,RWU=0,SBK=0 */
  SCI5CR2 = 12U;                                      
  /* ### Init_PIT init code */
  /* PITCFLMT: PITE=0 */
  PITCFLMT &= (unsigned char)~(unsigned char)128U;                     
  /* PITMTLD0: PMTLD7=0,PMTLD6=0,PMTLD5=0,PMTLD4=0,PMTLD3=0,PMTLD2=0,PMTLD1=0,PMTLD0=0 */
  PITMTLD0 = 0U;                                      
  /* PITMTLD1: PMTLD7=1,PMTLD6=1,PMTLD5=1,PMTLD4=1,PMTLD3=1,PMTLD2=1,PMTLD1=1,PMTLD0=1 */
  PITMTLD1 = 255U;                                      
  /* PITLD0: PLD15=0,PLD14=0,PLD13=0,PLD12=1,PLD11=1,PLD10=1,PLD9=1,PLD8=1,PLD7=0,PLD6=0,PLD5=1,PLD4=1,PLD3=1,PLD2=1,PLD1=1,PLD0=1 */
  PITLD0 = 7999U;                            
  /* PITLD1: PLD15=0,PLD14=1,PLD13=1,PLD12=1,PLD11=1,PLD10=0,PLD9=0,PLD8=1,PLD7=1,PLD6=1,PLD5=1,PLD4=1,PLD3=0,PLD2=1,PLD1=0,PLD0=0 */
  PITLD1 = 31220U;                            
  /* PITLD2: PLD15=0,PLD14=0,PLD13=0,PLD12=0,PLD11=0,PLD10=0,PLD9=0,PLD8=1,PLD7=1,PLD6=1,PLD5=0,PLD4=1,PLD3=0,PLD2=0,PLD1=1,PLD0=1 */
  PITLD2 = 467U;                            
  /* PITLD3: PLD15=1,PLD14=1,PLD13=1,PLD12=1,PLD11=1,PLD10=1,PLD9=1,PLD8=1,PLD7=1,PLD6=1,PLD5=1,PLD4=1,PLD3=1,PLD2=1,PLD1=1,PLD0=1 */
  PITLD3 = 65535U;                            
  /* PITLD4: PLD15=0,PLD14=0,PLD13=0,PLD12=0,PLD11=0,PLD10=1,PLD9=1,PLD8=0,PLD7=0,PLD6=0,PLD5=0,PLD4=1,PLD3=1,PLD2=0,PLD1=0,PLD0=1 */
  PITLD4 = 1561U;                            
  /* PITMUX: PMUX7=0,PMUX6=0,PMUX5=0,PMUX4=1,PMUX3=1,PMUX2=1,PMUX1=1,PMUX0=0 */
  PITMUX = 30U;                                      
  /* PITCE: PCE7=0,PCE6=0,PCE5=0,PCE4=0,PCE3=0,PCE2=0,PCE1=0,PCE0=0 */
  PITCE = 0U;                                      
  /* PITTF: PTF7=0,PTF6=0,PTF5=0,PTF4=1,PTF3=1,PTF2=1,PTF1=1,PTF0=1 */
  PITTF = 31U;                                      
  /* PITINTE: PINTE7=0,PINTE6=0,PINTE5=0,PINTE4=1,PINTE3=1,PINTE2=1,PINTE1=1,PINTE0=0 */
  PITINTE = 30U;                                      
  /* PITCFLMT: PITE=1,PITSWAI=0,PITFRZ=0,PFLMT1=0,PFLMT0=0 */
  PITCFLMT = 128U;                                      
  /* ### Init_ADC init code */
  /* Initialization of the ADC0 module */
  /* ATD0DIEN: IEN15=0,IEN14=0,IEN13=0,IEN12=0,IEN11=0,IEN10=0,IEN9=0,IEN8=0,IEN7=0,IEN6=0,IEN5=0,IEN4=0,IEN3=0,IEN2=0,IEN1=0,IEN0=0 */
  ATD0DIEN = 0U;                            
  /* ATD0CTL0: WRAP3=1,WRAP2=1,WRAP1=1,WRAP0=1 */
  ATD0CTL0 = 15U;                                      
  /* ATD0CTL1: ETRIGSEL=0,SRES1=1,SRES0=0,SMP_DIS=0,ETRIGCH3=1,ETRIGCH2=1,ETRIGCH1=1,ETRIGCH0=1 */
  ATD0CTL1 = 79U;                                      
  /* ATD0CTL3: DJM=1,S8C=1,S4C=1,S2C=1,S1C=0,FIFO=0,FRZ1=0,FRZ0=0 */
  ATD0CTL3 = 240U;                                      
  /* ATD0CTL4: SMP2=0,SMP1=0,SMP0=0,PRS4=0,PRS3=0,PRS2=1,PRS1=0,PRS0=1 */
  ATD0CTL4 = 5U;                                      
  /* ATD0CTL5: SC=0,SCAN=0,MULT=1,CD=0,CC=0,CB=0,CA=0 */
  ATD0CTL5 = 16U;                                      
  /* ATD0CTL2: AFFC=0,ICLKSTP=0,ETRIGLE=0,ETRIGP=0,ETRIGE=0,ASCIE=1,ACMPIE=0 */
  ATD0CTL2 = 2U;                                      
  /* ### Init_MSCAN init code */
  /* CAN0CTL0: INITRQ=1 */
  CAN0CTL0 |= (unsigned char)1U;                      
  while(CAN0CTL1_INITAK == 0U) {       /* Wait for init acknowledge */
  }
  /* CAN0CTL1: CANE=1,CLKSRC=1,LOOPB=0,LISTEN=0,BORM=0,WUPM=0,SLPAK=0,INITAK=1 */
  CAN0CTL1 = 193U;                                      
  /* CAN0BTR1: SAMP=0,TSEG22=0,TSEG21=1,TSEG20=1,TSEG13=1,TSEG12=0,TSEG11=1,TSEG10=0 */
  CAN0BTR1 = 58U;                                      
  /* CAN0BTR0: SJW1=0,SJW0=1,BRP5=0,BRP4=0,BRP3=0,BRP2=0,BRP1=1,BRP0=1 */
  CAN0BTR0 = 67U;                                      
  /* CAN0IDAC: IDAM1=0,IDAM0=1,IDHIT2=0,IDHIT1=0,IDHIT0=0 */
  CAN0IDAC = 16U;                                      
  /* CAN0IDAR0: AC7=1,AC6=0,AC5=1,AC4=1,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR0 = 176U;                                      
  /* CAN0IDAR1: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR1 = 0U;                                      
  /* CAN0IDAR2: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR2 = 0U;                                      
  /* CAN0IDAR3: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR3 = 0U;                                      
  /* CAN0IDAR4: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR4 = 0U;                                      
  /* CAN0IDAR5: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR5 = 0U;                                      
  /* CAN0IDAR6: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR6 = 0U;                                      
  /* CAN0IDAR7: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR7 = 0U;                                      
  /* CAN0IDMR0: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR0 = 255U;                                      
  /* CAN0IDMR1: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR1 = 255U;                                      
  /* CAN0IDMR2: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR2 = 255U;                                      
  /* CAN0IDMR3: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR3 = 255U;                                      
  /* CAN0IDMR4: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR4 = 255U;                                      
  /* CAN0IDMR5: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR5 = 255U;                                      
  /* CAN0IDMR6: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR6 = 255U;                                      
  /* CAN0IDMR7: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR7 = 255U;                                      
  /* CAN0CTL0: INITRQ=0 */
  CAN0CTL0 &= (unsigned char)~(unsigned char)1U;                     
  while(CAN0CTL1_INITAK) {             /* Wait for init exit */
  }
  /* CAN0CTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=0 */
  CAN0CTL0 = 0U;                                      
  /* CAN0RIER: WUPIE=0,CSCIE=0,RSTATE1=0,RSTATE0=0,TSTATE1=0,TSTATE0=0,OVRIE=0,RXFIE=1 */
  CAN0RIER = 1U;                                      
  /* CAN0TIER: TXEIE2=0,TXEIE1=0,TXEIE0=0 */
  CAN0TIER = 0U;                                      
  /* ### Init_PWM init code */
  /* PWME: PWME7=0,PWME6=0,PWME5=0,PWME4=0,PWME3=0,PWME2=0,PWME1=0,PWME0=0 */
  PWME = 0U;                           /* Disable all PWM channels */
  /* PWMPOL: PPOL7=0,PPOL6=0,PPOL5=0,PPOL4=0,PPOL3=0,PPOL2=0,PPOL1=0,PPOL0=0 */
  PWMPOL = 0U;                                      
  /* PWMCLK: PCLK7=0,PCLK6=0,PCLK5=0,PCLK4=0,PCLK3=0,PCLK2=0,PCLK1=0,PCLK0=0 */
  PWMCLK = 0U;                                      
  /* PWMCAE: CAE7=0,CAE6=0,CAE5=0,CAE4=0,CAE3=0,CAE2=0,CAE1=0,CAE0=0 */
  PWMCAE = 0U;                                      
  /* PWMCTL: CON67=0,CON45=0,CON23=0,CON01=0,PSWAI=0,PFRZ=0 */
  PWMCTL = 0U;                                      
  /* PWMDTY0: PWMDTY0=127 */
  PWMDTY0 = 127U;                                      
  /* PWMPER0: PWMPER0=255 */
  PWMPER0 = 255U;                                      
  /* PWMSCLA: BIT7=0,BIT6=0,BIT5=0,BIT4=0,BIT3=0,BIT2=0,BIT1=0,BIT0=0 */
  PWMSCLA = 0U;                                      
  /* PWMSCLB: BIT7=0,BIT6=0,BIT5=0,BIT4=0,BIT3=0,BIT2=0,BIT1=0,BIT0=0 */
  PWMSCLB = 0U;                                      
  /* PWMPRCLK: PCKB2=0,PCKB1=0,PCKB0=0,PCKA2=1,PCKA1=1,PCKA0=1 */
  PWMPRCLK = 7U;                                      
  /* PWMSDN: PWMIF=1,PWMIE=0,PWMRSTRT=0,PWMLVL=0,PWM7IN=0,PWM7INL=0,PWM7ENA=0 */
  PWMSDN = 128U;                                      
  /* PWME: PWME7=0,PWME6=0,PWME5=0,PWME4=0,PWME3=0,PWME2=0,PWME1=0,PWME0=1 */
  PWME = 1U;                           /* Enable only configured PWM channels */
  /* ### Init_MSCAN init code */
  /* CAN1CTL0: INITRQ=1 */
  CAN1CTL0 |= (unsigned char)1U;                      
  while(CAN1CTL1_INITAK == 0U) {       /* Wait for init acknowledge */
  }
  /* CAN1CTL1: CANE=1,CLKSRC=1,LOOPB=0,LISTEN=0,BORM=0,WUPM=0,SLPAK=0,INITAK=1 */
  CAN1CTL1 = 193U;                                      
  /* CAN1BTR1: SAMP=0,TSEG22=0,TSEG21=1,TSEG20=1,TSEG13=1,TSEG12=0,TSEG11=1,TSEG10=0 */
  CAN1BTR1 = 58U;                                      
  /* CAN1BTR0: SJW1=0,SJW0=1,BRP5=0,BRP4=0,BRP3=0,BRP2=0,BRP1=0,BRP0=0 */
  CAN1BTR0 = 64U;                                      
  /* CAN1IDAC: IDAM1=0,IDAM0=1,IDHIT2=0,IDHIT1=0,IDHIT0=0 */
  CAN1IDAC = 16U;                                      
  /* CAN1IDAR0: AC7=1,AC6=0,AC5=1,AC4=1,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR0 = 176U;                                      
  /* CAN1IDAR1: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR1 = 0U;                                      
  /* CAN1IDAR2: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR2 = 0U;                                      
  /* CAN1IDAR3: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR3 = 0U;                                      
  /* CAN1IDAR4: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR4 = 0U;                                      
  /* CAN1IDAR5: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR5 = 0U;                                      
  /* CAN1IDAR6: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR6 = 0U;                                      
  /* CAN1IDAR7: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR7 = 0U;                                      
  /* CAN1IDMR0: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR0 = 255U;                                      
  /* CAN1IDMR1: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR1 = 255U;                                      
  /* CAN1IDMR2: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR2 = 255U;                                      
  /* CAN1IDMR3: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR3 = 255U;                                      
  /* CAN1IDMR4: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR4 = 255U;                                      
  /* CAN1IDMR5: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR5 = 255U;                                      
  /* CAN1IDMR6: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR6 = 255U;                                      
  /* CAN1IDMR7: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR7 = 255U;                                      
  /* CAN1CTL0: INITRQ=0 */
  CAN1CTL0 &= (unsigned char)~(unsigned char)1U;                     
  while(CAN1CTL1_INITAK) {             /* Wait for init exit */
  }
  /* CAN1CTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=0 */
  CAN1CTL0 = 0U;                                      
  /* CAN1RIER: WUPIE=0,CSCIE=0,RSTATE1=0,RSTATE0=0,TSTATE1=0,TSTATE0=0,OVRIE=0,RXFIE=1 */
  CAN1RIER = 1U;                                      
  /* CAN1TIER: TXEIE2=0,TXEIE1=0,TXEIE0=0 */
  CAN1TIER = 0U;                                      
  /* ### Init_GPIO init code */
  /* DDRA: DDRA7=1,DDRA6=1,DDRA5=1,DDRA4=1,DDRA3=1,DDRA2=1,DDRA1=1,DDRA0=1 */
  DDRA = 255U;                                      
  /* ### */
  /* Initial interrupt priority */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm {
    PSHA
    LDAA #0
    TFR A,CCRH
    PULA
    CLI                                /* Enable interrupts */
  };
  /*lint -restore Enable MISRA rule (1.1) checking. */
} /*MCU_init*/

#pragma MESSAGE DEFAULT C12056

/*lint -save  -e765 Disable MISRA rule (8.10) checking. */
#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isr_default
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isr_default(void)
{
  /* Write your interrupt code here ... */

}
/* end of isr_default */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVatd0compare
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVatd0compare(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVatd0compare */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT4_10Hz
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT4_10Hz(void)
{

   //TODO: il manque la définition de ID_618 et gi
    /*
    CAN0SendCommand(COMMAND_BAL,0x3F,0xFFF,glowestV);//3F = broadcast
    if(gi == 0)
      {
        
        CAN1SendChar(ID_618,0x3,7,gbrusa1); //(unsigned long id, unsigned char priority, unsigned char length, unsigned char *txdata )
        gi = 1;      
      }
    else
      {
        CAN1SendChar(ID_618,0x3,7,gbrusa2); //(unsigned long id, unsigned char priority, unsigned char length, unsigned char *txdata ) 
      }
     */
}
/* end of iPIT4_10Hz */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT3_sci_cont_mode
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT3_sci_cont_mode(void)
{

   //SCIcontinuous();

   
   SCIprintStatus();
   SCITx(status_menu_3, 0 ,1);   //"Affichage des données en mode continu pour le module " 
   print_string(num_module,0);	 //numero de module				
   skip_lines(1);	
   				
   get_cells_data(gCellVolt, gCellTemp, num_module - 1 ,gMesuresParams.N_CELL );
   skip_lines(2);  

   
   PITTF_PTF3 = 1; //clear le interrupt flag	 	 
}
/* end of iPIT3_sci_cont_mode */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT2_adc_timeout
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT2_adc_timeout(void)
{
   //Clearing the PIT2 interrupt flag
   PITTF = (PITTF | 0x4);

   //Starting the AN2 to AN15 conversion sequence (ADC0)
   ATD0CTL5_CB = 1;
}
/* end of iPIT2_adc_timeout */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT1_slave_comm_timeout
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT1_slave_comm_timeout(void)
{
  unsigned char i = 0;
  unsigned int tmp=0;

  PITTF_PTF1 = 1; //raz du flag
  
  for(i=0; i < gMesuresParams.N_MOD; ++i) {

    tmp = (1<<i);

    //Si on a pas déja perdu la connection, on augmente le compteur
    if(!((gSlaveComState & tmp) == tmp))
      idleCount[i]++;
    
    if(idleCount[i] > COM_IDLE_COUNT_MAX) {
      gSlaveComState = gSlaveComState | tmp;    // Il y a un slave de déconnecté
      gErrorBits = (gErrorBits | ERROR_SLV_COM_TO);
      
    } else {
      gSlaveComState = gSlaveComState & ~tmp;
    }
  }
}
/* end of iPIT1_slave_comm_timeout */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVpit0
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVpit0(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVpit0 */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : SCIIsr
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void SCIIsr(void)
{

   unsigned char i;
   unsigned char termchar;                         // byte reçu du terminal 

   static char inputBuf[20] = "";
   static unsigned char bufPos = 0;
   float inputParam = 0;
   static unsigned char point = 0;

   if (!(SCI5SR1 & 0x20))  //If reception flag is not set
      return;
 
   termchar = SCI5DRL; // enregistrement du byte reçu + clear le reception flag
   

//**************************************************
// "m" KEY	  
//**************************************************
	if (termchar == 'm')
	{		
		niveau_1 = 0;                 // 1 = configuration, 2 = status, 3 = commandes
		niveau_2 = 0;
		niveau_3 = 0;
		SCIshowMenu(0);               // input = 0 -> show the menu for the actual levels
		sci_interrupt_mode = 0;
		for(i=0; i<20; i++)
	      inputBuf[i] = 0;
	}
		
//**************************************************
// BS KEY
//
// Lorsque l'usager appuie sur BS, la saisie de donné est interrompu.
// Le menu de niveau supérieur est réaffiché
//**************************************************	
	else if(termchar == 0x08) //BS Back Space == 0x08	 
	{			   
      if((niveau_1 == 2) && (niveau_2 == 3))        //Désactivation du mode continu
         PITCE_PCE3 = 0;
      
      sci_interrupt_mode = 0;   
      SCIupAlevel();
      SCIshowMenu(0);
      
      for(i=0; i<20; i++)
	      inputBuf[i] = 0;
	}	
		
//**************************************************
// MODE MENU
//
// Affiche le menu approprié selon les niveaux 1, 2 et 3 et la commande recu	  
//**************************************************
   else if  (sci_interrupt_mode == 0) 
   {
      SCIshowMenu(termchar);    
   }
   	
//**************************************************
// MODE ASSIGNATION
//	
// Assignation de la valeur lorsque l'usager appuie sur "enter"
//**************************************************
	else if (termchar == 0xD && sci_interrupt_mode == 1)  // CR == enter key		
	{

	   if(sscanf(inputBuf, "%f", &inputParam) > 0)
      {
          SCIassignation(inputParam);
          
      } else {
         
          SCIprintString("Error reading the entered value.\n");
      }


      if(sci_interrupt_mode != 2) {
          sci_interrupt_mode = 0;
   	    SCIupAlevel();
          SCIshowMenu(0);
   	}
   	
	    inputParam = 0;
	    bufPos = 0;
	    point = 0;
	    for(i=0; i<20; i++)
	    inputBuf[i] = 0;
    
	}
	
//**************************************************
// MODE USER_INPUT	
//**************************************************
	else if (sci_interrupt_mode == 1) 
   { 
   
      if(termchar == '-'){
         if(bufPos == 0){
           inputBuf[bufPos++] = termchar;
           SCIPutChar(termchar);
         }
      } else if(termchar == '.'){
         if((bufPos != 0) && (bufPos < 19) && !point){
            inputBuf[bufPos++] = termchar;
            point = 1;
            SCIPutChar(termchar);
         }
      } else if((termchar >= '0') && (termchar <= '9')){
         if(bufPos < 19){
            inputBuf[bufPos++] = termchar; 
            SCIPutChar(termchar);
         }
      } 
   }		

   return;
} 

/* end of SCIIsr */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVpwmesdn
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVpwmesdn(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVpwmesdn */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan1tx
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan1tx(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan1tx */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iCAN1RX_reception
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iCAN1RX_reception(void)
{
    uchar length, indexRx,i=0;
    unsigned char rxdata[8] = {0,0,0,0,0,0,0,0};
     
    RXID = CAN1RXIDR0 <<3 | CAN1RXIDR1 >> 5;
    
    //on récupère la longueur du message (8 octets max) 
    length = (CAN1RXDLR & 0x0F);
      
    //le buffer de réception est de type FIFO et est long de 15 octets
	 for (indexRx=0; indexRx<length; indexRx++)
  	    rxdata[indexRx] = *(&CAN1RXDSR0 + indexRx); //on récupère les données	  
      
	 //pour lever l'interruption et relâcher le buffer de réception foregroung
    CAN1RFLG_RXF = 1; 
}
/* end of iCAN1RX_reception */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan0err
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan0err(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan0err */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan0wkup
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan0wkup(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan0wkup */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan0tx
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan0tx(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan0tx */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iCANRX_reception
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iCANRX_reception(void)
{
    
    uchar length, indexRx,i=0,thisSlave;
    unsigned char rxdata[8] = {0,0,0,0,0,0,0,0};
    unsigned int rcvVolt;
    int rcvTemp;
    unsigned int cellNb;
    unsigned int errorCode = 0;
    unsigned int command = 0;
    unsigned int param1 = 0;
    unsigned int param2 = 0;
    unsigned int tmp;
     
    RXID = CAN0RXIDR0 <<3 | CAN0RXIDR1 >> 5;
    
    //on récupère la longueur du message (8 octets max) 
    length = (CAN0RXDLR & 0x0F);
      
    //le buffer de réception est de type FIFO et est long de 15 octets
	 for (indexRx=0; indexRx<length; indexRx++)
  	    rxdata[indexRx] = *(&CAN0RXDSR0 + indexRx); //on récupère les données
	 
	 //Open connection measurement received
    //TODO: en temps normal, on devrait recevoir un message indiquant l'esclave et la cellule
    //      avec une connection ouverte.
    //      durant init, on devrait recevoir un message nous assurant qu'aucune cellule n'est
    //      débranchée.
  

	 
	 //Voltages measurements received
	  
	  if(RXID>=0x580 && RXID<0x680)
	  {
        thisSlave = (unsigned char) ((RXID-0x580-RXID%4)>>2);
        
        if(idleCount[thisSlave] > 0)
           idleCount[thisSlave]--;
        
        //Received 1 to 4 voltages (unsigned integers)
        for(i=0; i < (length>>1); i++) {
        
           cellNb = RXID%4*4+i;
           rcvVolt = ((unsigned int) rxdata[2*i] << 8 ) | rxdata[2*i+1];
	        gCellVolt[thisSlave][cellNb] = rcvVolt;
	        
	        //Verifiy for too large or low measurements
	        if(rcvVolt < gSecurityParams.V_MIN) {            //TODO: Check for the threshold first
	          
	           //if(rcvVolt < gSecurityParams.V_MIN_LIM) {
	              gErrorBits = (gErrorBits | ERROR_MIN_VOLT);
	           //}
	           
	        } else if(rcvVolt > gSecurityParams.V_MAX) {     //TODO: Check for the threshold first
	        
	           //if(rcvVolt > gSecurityParams.V_MAX_LIM) {
	              gErrorBits = (gErrorBits | ERROR_MAX_VOLT);
	           //}
	        }
	     }
	  }
	    
	
   //Temperature measurements received	    
   else if(RXID>=0x680 && RXID<0x780)
   {
      thisSlave = (unsigned char) ((RXID-0x680-RXID%4)>>2);
      
      if(idleCount[thisSlave] > 0)
         idleCount[thisSlave]--;
      
      //Received 1 to 4 temperatures (unsigned integers)
      for(i=0; i < (length>>1); i++) {
      
         cellNb = RXID%4*4+i;
         rcvTemp = ((unsigned int) rxdata[2*i] << 8) |  rxdata[2*i+1];
         
         //MATH: patch pour contrer les 4 canaux de l'ADC esclave 0 brisés
         if((thisSlave == 0) && (cellNb < 4)){
            rcvTemp = 200;
            gCellTemp[thisSlave][cellNb] = 200;
         }
         
         gCellTemp[thisSlave][cellNb] = rcvTemp;
         
         //Verifiy for too large or low measurements
         if((gMode == NORMAL_MODE) || (gMode == STAND_BY_MODE)) {
         
            if(rcvTemp < gSecurityParams.TD_MIN) {
   	                         
               //TODO: set threshold flag or something
               //if(rcvTemp < gSecurityParams.TD_MIN_LIM) {
                  gErrorBits = (gErrorBits | ERROR_MIN_TEMP);
               //}
                 
            } else if(rcvTemp > gSecurityParams.TD_MAX) {
              
               //TODO: set threshold flag or something
               //if(rcvTemp > gSecurityParams.TD_MAX_LIM) {
                  gErrorBits = (gErrorBits | ERROR_MAX_TEMP);
               //}
            }
            
         } else if(gMode == CHARGE_MODE) {
         
            if(rcvTemp < gSecurityParams.TC_MIN) {
   	          
               //TODO: set threshold flag or something
               //if(rcvTemp < gSecurityParams.TC_MIN_LIM) {
                  gErrorBits = (gErrorBits | ERROR_MIN_TEMP);
               //}
                 
            } else if(rcvTemp > gSecurityParams.TC_MAX) {
              
               //TODO: set threshold flag or something
               //if(rcvTemp > gSecurityParams.TC_MAX_LIM) {
                  gErrorBits = (gErrorBits | ERROR_MAX_TEMP);
               //}
            }
         }
      }
      
   //Message received from a slave     
   } else if(RXID>=0x780 && RXID<0x78A) {
	 
	   thisSlave = (unsigned char) (RXID-0x780);
	   command = ((unsigned int)rxdata[0])<<8 | rxdata[1];
      errorCode = ((unsigned int)rxdata[6])<<8 | rxdata[7]; 
      
      if(idleCount[thisSlave] > 0)
         idleCount[thisSlave]--;
      
      if ((command == COMMAND_BAL_DONE) && (errorCode == 0xFFFF)) {
         tmp = 1<<thisSlave;
         gSlaveEquiStatus = (gSlaveEquiStatus & ~tmp);
         
         if((gSlaveEquiStatus == 0) && gActivEqui)
            gActivEqui = 0;
      }
   }
      
	 //pour lever l'interruption et relâcher le buffer de réception foregroung
    CAN0RFLG_RXF = 1; 

}
/* end of iCANRX_reception */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iADC_sequence_complete
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iADC_sequence_complete(void)
{

  static unsigned int iCurrent = 0;                 //index of the current position in the table 
  static long int currConv = 0;                     //Conversion register for the current    
  static long int* currTable = gCurrentMsr1;        //Pointer to the table that is being filled                                        
  unsigned long int variable = 0;                   // Use in the adc_Interrupt
  long int temp=0;

  //If the gnd fault reading is superior to 2.5V, set an error
  gFaultMeasure = ATD0DR0; 
  if(gFaultMeasure > 2048)
      gErrorBits = (gErrorBits | ERROR_GND_FAULT);
  
  
  //If the ignition reading is superior to 2.5V, ignition is on
  if(ATD0DR1 > 2048)
      gIgnition = 1;
  else
      gIgnition = 0;    
   
      
  //If the CH1 reading is superior to 4.75V or inferior to 0.25V,
  //take the ch2 current measurement
 if((ATD0DR13 < 205) || (ATD0DR13 > 3891)){
     
           
       if(ATD0DR5 > O_HALL2){
                    
          variable = ATD0DR5-O_HALL2;
          currConv = variable * K_HALL2;         // CH2: 210 mA par division sur 12 bits (4096 div)
                                             //      pour une tension moyenne de référence de 4,9 V
       }else{                
        
        variable = O_HALL2 - ATD0DR5;
        currConv = -1*variable * K_HALL2;
       }
   
  } else {
    
       if(ATD0DR13 > O_HALL1){
                    
          variable = ATD0DR13-O_HALL1;
          currConv = variable * K_HALL1;         // CH2: 18 mA par division sur 12 bits (4096 div)
       }else{                               //      pour une tension moyenne de référence de 4,9 V
        
        variable = O_HALL1 - ATD0DR13;
        currConv = -1*variable * K_HALL1;
       }
  }
  
  gLastCurrent = currConv;
  
  temp = 1000*(long int)gSecurityParams.IDP_MAX;
  
  if((gLastCurrent > temp) || (gLastCurrent < -temp)) {
      gErrorBits = gErrorBits | ERROR_MAX_PEAK_CURR;    
  }
  
  currTable[iCurrent++] = currConv;
  
  
  //If the current measurement buffer is full, reset index to 0, switch buffers and
  //set the SOCready flag so a SOC calculation will eventually start
  if(iCurrent == N_CURR_MSR){
      iCurrent = 0;
      gSOCready = 1;
      
      if(currTable == gCurrentMsr1){
         currTable = gCurrentMsr2;
         gCurrentMsr = gCurrentMsr1;    // Hugues Temporary
      } else {
         currTable = gCurrentMsr1;
         gCurrentMsr = gCurrentMsr2;    // Hugues Temporary
      }
  }
  
  //gFirstADCdone = 1;
  
   //raz du flag (pas le choix si on veut sortir de l'interrupt)
  ATD0STAT0_SCF = 1;
       
}
/* end of iADC_sequence_complete */
#pragma CODE_SEG DEFAULT


/*lint -restore Enable MISRA rule (8.10) checking. */

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
/* Initialization of the CPU registers in FLASH */
/*lint -restore Enable MISRA rule (1.1) checking. */




/* Interrupt vector table */


/* ISR prototype */
typedef void (*near tIsrFunc)(void);

#ifndef UNASSIGNED_ISR
  #define UNASSIGNED_ISR isr_default   /* unassigned interrupt service routine */
#endif
/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
static const tIsrFunc _InterruptVectorTable[] @0xFF10U = { /* Interrupt vector table */
/*lint -restore Enable MISRA rule (1.1) checking. */
  /* ISR name                               No.  Address Pri XGATE Name            Description */
  &UNASSIGNED_ISR,                      /* 0x08  0xFF10   -   -    ivVsi           unused by PE */
  &UNASSIGNED_ISR,                      /* 0x09  0xFF12   -   -    ivVsyscall      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0A  0xFF14   -   -    ivVmpuaccesserr unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0B  0xFF16   -   no   ivVxsei         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0C  0xFF18   1   no   ivVReserved115  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0D  0xFF1A   1   no   ivVReserved114  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0E  0xFF1C   1   no   ivVReserved113  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0F  0xFF1E   1   no   ivVReserved112  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x10  0xFF20   1   no   ivVReserved111  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x11  0xFF22   1   no   ivVReserved110  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x12  0xFF24   1   no   ivVReserved109  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x13  0xFF26   1   no   ivVReserved108  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x14  0xFF28   1   no   ivVReserved107  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x15  0xFF2A   1   no   ivVReserved106  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x16  0xFF2C   1   no   ivVReserved105  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x17  0xFF2E   1   no   ivVReserved104  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x18  0xFF30   1   no   ivVReserved103  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x19  0xFF32   1   no   ivVReserved102  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1A  0xFF34   1   no   ivVReserved101  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1B  0xFF36   1   no   ivVReserved100  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1C  0xFF38   1   no   ivVReserved99   unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1D  0xFF3A   1   no   ivVReserved98   unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1E  0xFF3C   1   no   ivVatd1compare  unused by PE */
  &isrVatd0compare,                     /* 0x1F  0xFF3E   1   no   ivVatd0compare  used by PE */
  &UNASSIGNED_ISR,                      /* 0x20  0xFF40   1   no   ivVtimpaie      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x21  0xFF42   1   no   ivVtimpaaovf    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x22  0xFF44   1   no   ivVtimovf       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x23  0xFF46   1   no   ivVtimch7       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x24  0xFF48   1   no   ivVtimch6       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x25  0xFF4A   1   no   ivVtimch5       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x26  0xFF4C   1   no   ivVtimch4       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x27  0xFF4E   1   no   ivVtimch3       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x28  0xFF50   1   no   ivVtimch2       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x29  0xFF52   1   no   ivVtimch1       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2A  0xFF54   1   no   ivVtimch0       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2B  0xFF56   1   no   ivVsci7         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2C  0xFF58   1   no   ivVpit7         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2D  0xFF5A   1   no   ivVpit6         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2E  0xFF5C   1   no   ivVpit5         unused by PE */
  &iPIT4_10Hz,                          /* 0x2F  0xFF5E   1   no   ivVpit4         used by PE */
  &UNASSIGNED_ISR,                      /* 0x30  0xFF60   1   no   ivVReserved79   unused by PE */
  &UNASSIGNED_ISR,                      /* 0x31  0xFF62   1   no   ivVReserved78   unused by PE */
  &UNASSIGNED_ISR,                      /* 0x32  0xFF64   1   no   ivVxst7         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x33  0xFF66   1   no   ivVxst6         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x34  0xFF68   1   no   ivVxst5         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x35  0xFF6A   1   no   ivVxst4         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x36  0xFF6C   1   no   ivVxst3         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x37  0xFF6E   1   no   ivVxst2         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x38  0xFF70   1   no   ivVxst1         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x39  0xFF72   1   no   ivVxst0         unused by PE */
  &iPIT3_sci_cont_mode,                 /* 0x3A  0xFF74   1   no   ivVpit3         used by PE */
  &iPIT2_adc_timeout,                   /* 0x3B  0xFF76   1   no   ivVpit2         used by PE */
  &iPIT1_slave_comm_timeout,            /* 0x3C  0xFF78   1   no   ivVpit1         used by PE */
  &isrVpit0,                            /* 0x3D  0xFF7A   1   no   ivVpit0         used by PE */
  &UNASSIGNED_ISR,                      /* 0x3E  0xFF7C   1   -    ivVhti          unused by PE */
  &UNASSIGNED_ISR,                      /* 0x3F  0xFF7E   1   no   ivVapi          unused by PE */
  &UNASSIGNED_ISR,                      /* 0x40  0xFF80   1   no   ivVlvi          unused by PE */
  &UNASSIGNED_ISR,                      /* 0x41  0xFF82   1   no   ivVReserved62   unused by PE */
  &SCIIsr,                              /* 0x42  0xFF84   1   no   ivVsci5         used by PE */
  &UNASSIGNED_ISR,                      /* 0x43  0xFF86   1   no   ivVsci4         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x44  0xFF88   1   no   ivVsci3         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x45  0xFF8A   1   no   ivVsci2         unused by PE */
  &isrVpwmesdn,                         /* 0x46  0xFF8C   1   no   ivVpwmesdn      used by PE */
  &UNASSIGNED_ISR,                      /* 0x47  0xFF8E   1   no   ivVportp        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x48  0xFF90   1   no   ivVcan4tx       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x49  0xFF92   1   no   ivVcan4rx       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4A  0xFF94   1   no   ivVcan4err      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4B  0xFF96   1   no   ivVcan4wkup     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4C  0xFF98   1   no   ivVcan3tx       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4D  0xFF9A   1   no   ivVcan3rx       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4E  0xFF9C   1   no   ivVcan3err      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4F  0xFF9E   1   no   ivVcan3wkup     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x50  0xFFA0   1   no   ivVcan2tx       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x51  0xFFA2   1   no   ivVcan2rx       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x52  0xFFA4   1   no   ivVcan2err      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x53  0xFFA6   1   no   ivVcan2wkup     unused by PE */
  &isrVcan1tx,                          /* 0x54  0xFFA8   1   no   ivVcan1tx       used by PE */
  &iCAN1RX_reception,                   /* 0x55  0xFFAA   1   no   ivVcan1rx       used by PE */
  &isrVcan0err,                         /* 0x56  0xFFAC   1   no   ivVcan1err      used by PE */
  &isrVcan0wkup,                        /* 0x57  0xFFAE   1   no   ivVcan1wkup     used by PE */
  &isrVcan0tx,                          /* 0x58  0xFFB0   1   no   ivVcan0tx       used by PE */
  &iCANRX_reception,                    /* 0x59  0xFFB2   1   no   ivVcan0rx       used by PE */
  &isrVcan0err,                         /* 0x5A  0xFFB4   1   no   ivVcan0err      used by PE */
  &isrVcan0wkup,                        /* 0x5B  0xFFB6   1   no   ivVcan0wkup     used by PE */
  &UNASSIGNED_ISR,                      /* 0x5C  0xFFB8   1   no   ivVflash        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x5D  0xFFBA   1   no   ivVflashfd      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x5E  0xFFBC   1   no   ivVspi2         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x5F  0xFFBE   1   no   ivVspi1         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x60  0xFFC0   1   no   ivViic0         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x61  0xFFC2   1   no   ivVsci6         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x62  0xFFC4   1   no   ivVcrgscm       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x63  0xFFC6   1   no   ivVcrgplllck    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x64  0xFFC8   1   no   ivVectpabovf    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x65  0xFFCA   1   no   ivVectmdcu      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x66  0xFFCC   1   no   ivVporth        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x67  0xFFCE   1   no   ivVportj        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x68  0xFFD0   1   no   ivVatd1         unused by PE */
  &iADC_sequence_complete,              /* 0x69  0xFFD2   1   no   ivVatd0         used by PE */
  &UNASSIGNED_ISR,                      /* 0x6A  0xFFD4   1   no   ivVsci1         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6B  0xFFD6   1   no   ivVsci0         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6C  0xFFD8   1   no   ivVspi0         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6D  0xFFDA   1   no   ivVectpaie      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6E  0xFFDC   1   no   ivVectpaaovf    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6F  0xFFDE   1   no   ivVectovf       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x70  0xFFE0   1   no   ivVectch7       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x71  0xFFE2   1   no   ivVectch6       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x72  0xFFE4   1   no   ivVectch5       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x73  0xFFE6   1   no   ivVectch4       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x74  0xFFE8   1   no   ivVectch3       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x75  0xFFEA   1   no   ivVectch2       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x76  0xFFEC   1   no   ivVectch1       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x77  0xFFEE   1   no   ivVectch0       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x78  0xFFF0   1   no   ivVrti          unused by PE */
  &UNASSIGNED_ISR,                      /* 0x79  0xFFF2   1   no   ivVirq          unused by PE */
  &UNASSIGNED_ISR,                      /* 0x7A  0xFFF4   -   -    ivVxirq         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x7B  0xFFF6   -   -    ivVswi          unused by PE */
  &UNASSIGNED_ISR                       /* 0x7C  0xFFF8   -   -    ivVtrap         unused by PE */
};

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
static const tIsrFunc _ResetVectorTable[] @0xFFFAU = { /* Reset vector table */
/*lint -restore Enable MISRA rule (1.1) checking. */
  /* Reset handler name                    Address Name             Description */
  &MCU_init_reset,                      /* 0xFFFA  ivVcop           unused by PE */
  &MCU_init_reset,                      /* 0xFFFC  ivVclkmon        unused by PE */
  &MCU_init_reset                       /* 0xFFFE  ivVreset         used by PE */
};


/* END MCUinit */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.02 [04.44]
**     for the Freescale HCS12X series of microcontrollers.
**
** ###################################################################
*/
