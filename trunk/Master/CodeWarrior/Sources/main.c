// Freescale Headers
#include <hidef.h>
#include "derivative.h"

// C STD Headers
#include <string.h>
#include <stdio.h>

// BMS specific Headers
#include "MCUinit.h"
#include "termio.h" 
#include "terminal_code.h"
#include "can.h"
#include "relays.h"
#include "common.h"


//#define DEBUG

  
/*********************
   Global variables
*********************/

//-------
// Flags
//-------
                              
errors_t gError = {0,0,0,0,0,0,0,0};
flags_t gFlags = {0,0,0,0,0,0,0,0,0,0,0,0,0};                                    
                                    
unsigned int gSlaveEquiStatus = 0;      //Si le i-ème bit est à 1, le (i+1)-ème module est en équilibration
unsigned int gSlaveComState = 0;        //Si le i-ème bit est à 1, le (i+1)-ème module est en erreur de communication                               

//-----------
// Variables
//-----------

uint16 gCellVolt[N_MOD][N_CELL];                    // [mV] Cell voltages
uint16 *gLowestCellVoltage = &gCellVolt[0][0];      // [mV] 
uint16 *gHighestCellVoltage = &gCellVolt[0][0];     // [mV] 
long int gMeanCurrent = 0;                          //[mA]

int gCellTemp[N_MOD][N_CELL];                       // [dixieme oC] Cell temperatures  
int *gLowestCellTemp = &gCellTemp[0][0];            // [dixieme oC]
int *gHighestCellTemp = &gCellTemp[0][0];           // [dixieme oC]0;         

uint8 gMode = STAND_BY_MODE;                       // Operating mode
uint8 gLastMode = STAND_BY_MODE;                   // Last main cycle operating mode

uint8 idleCount[N_MOD];
uint8 gSlaveReset[N_MOD];
uint8 gSlaveRev[N_MOD];

params_t gParams =   {
                       -300,  //minDischargeCellTemp (oC / 10)
                        700,  //maxDischargeCellTemp
                       -200,  //lowDischargeCellTemp
                        600,  //highDischargeCellTemp
                       -100,  //minChargeCellTemp
                        800,  //maxChargeCellTemp
                          0,  //lowChargeCellTemp
                        450,  //highChargeCellTemp
                       2600,  //minCellVoltage  (mV)
                       4300,  //maxCellVoltage  (mV)
                       3000,  //lowCellVoltage  (mV)
                       4250,  //highCellVoltage  (mV)
                         93,  //maxMeanChargeCurrent  (A)
                        250,  //maxMeanDischargeCurrent  (A)
                        250,  //highPeakDischargeCurrent (A)        //TODO: vérifier avec Hugues
                        340,   //maxPeakDischargeCurrent   (A) (moins de 10 secondes)
                        0      //manualMode
                    };

void MCU_init(void);
void errorMode(void);
void standbyMode(void);
void normalMode(void);
void modeSelection(void);
void deviceInit(void);
void resetVoltWarnings(void);
void resetTempWarnings(void);
void resetTempErrors(void);
void resetVoltErrors(void);


/***********************
   Main program start
***********************/

void main(void)
{          
    deviceInit();

    
	//En mode automatique on attend d'avoir reçu
	//les premières valeurs de tensions et de température de toutes les cellules
    //et les premières mesures de faute de masse et de courant
	//de façon à ne pas démarrer la voiture avant de savoir s'il y a un problème.
    //TODO: flag 'ready'? reset du flag après 'résumation' du mode erreur?
    while(!gFlags.allCellsKnown || !gFlags.currentKnown || !gFlags.interlockStateKnown) {
        if(gParams.manualMode) break;
    }    
    
    //Requête du numéro de révision des esclaves
    CAN0RequestSlaveFirmware(CAN_BROADCAST_ID);

	
    while(1) {
        
        if(!gParams.manualMode) {        //Automatic mode

            gLastMode = gMode;
            modeSelection();

            switch(gMode) 
            {
                case NORMAL_MODE:    normalMode(); break;
                case STAND_BY_MODE:  standbyMode(); break;
                case ERROR_MODE:     errorMode(); break;
                default:  errorMode();
            } 
        }
    }
}


//*****************************************************************************
// deviceInit
//
// Description:   This function initializes the BMS. It uses the MCU_init
//                function generated by the Device Initialization tool. 
//
//*****************************************************************************
void deviceInit()
{
    int i,j;
       
    #ifdef DEBUG
      TERMIO_PutString("deviceInit: device initialization\n");
    #endif

    //Initialization of the uC peripherals
   //--------------------------------------------------------
   //Timers initiazed for
   //    - Cell measurements refresh every 2 seconds using PIT3 (in user interface continuous mode)
   //    - Mesure du couran chaque 100 ms (PIT2), avec une moyenne mobile exponentielle
   //    de poids alpha = 0.125 donc 86% du poids des valeurs pris dans les 15 dernières mesures (1.5 sec).
   //    - On détermine l'état de ignition et interlock state chaque 100 ms (PIT2).
   //    - Communication with the slave modules timeout tick every 1 second using PIT1
   //    warning led flashes with help of PIT4 at 4Hz
   
    MCU_init();
    
    for(i=0; i<N_MOD; i++){
        for(j=0; j<N_CELL; j++){
            gCellVolt[i][j] = 0;
            gCellTemp[i][j] = 0;
        }
        idleCount[i] = 0;
        gSlaveReset[i] = 0;
        gSlaveRev[i] = 0;   
    }

   //Sélection du channel AN7 comme channel de départ de l'ADC
   ATD0CTL5 = ATD0CTL5 | 0x07;
    
    
   //User interface initialization
   SCI5CR2_RIE = 1;                   //Receiver Full Interrupt Enable Bit activation
   SCI5BD = USER_INT_SPEED;           //On assigne la bonne vitesse de transmission
   
   //Timers activation
   PITCE_PCE1 = 1;                   //Activation of the slave communication timeout timer (PIT1)
   PITCE_PCE2 = 1;                   //Activation of the ADC timer (PIT2)
   PITCE_PCE4 = 1;                   //Activation of the warning led flash timer (PIT4)
   PITCFLMT_PITE = 1;                //Activation of the timer module
}


//*****************************************************************************
// modeSelection
//
// Description:   This function will determine in which state (mode) the BMS
//                is. 
//
//*****************************************************************************
void modeSelection()
{
    uint16 anyError = *((uint16*) &gError);

    if(anyError != 0) {
      gMode = ERROR_MODE;
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("modeSelection: ERROR MODE selected\n"); 
      #endif  
  
   } else if(gFlags.ignition && gFlags.interlockClosed) {
      gMode = NORMAL_MODE;
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("modeSelection: NORMAL MODE selected\n"); 
      #endif
      
   } else {
      gMode = STAND_BY_MODE;
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("modeSelection: STAND-BY MODE selected\n");
      #endif          
   }
}


//*****************************************************************************
// normalMode
//
// Description:   This function implements the actions undertaken when the 
//                BMS is in normal mode i.e. ignition is on and there is no
//                charging process. 
//
//*****************************************************************************
void normalMode()
{  
    if(gMode != gLastMode){
        if(!gFlags.relaysClosed){
            #ifdef DEBUG
            TERMIO_PutString("normalMode: closing the relays\n");
            #endif
            //Fermeture des relais du circuit principal avec précharge.
            //Ouverture du circuit de décharge.
            if(gFlags.interlockClosed)
                CloseRelays();
            gFlags.relaysClosed = 1;
        }
    }
}


//*****************************************************************************
// standbyMode
//
// Description:   This function implements the actions undertaken when the 
//                BMS is in stand-by mode i.e. ignition is off and no charging
//                process is going on.
//
//*****************************************************************************
void standbyMode()
{
    if(gMode != gLastMode){
        if(gFlags.relaysClosed){

            #ifdef DEBUG
            TERMIO_PutString("standbyMode: opening the relays\n");
            #endif      

            //Opening the relays
            OpenRelays();        
            gFlags.relaysClosed = 0;
        }   
    }
}


//*****************************************************************************
// errorMode
//
// Description:   This function implements the actions undertaken when the 
//                BMS is in error mode i.e. any error was detected.
//
//*****************************************************************************
void errorMode(){

   //Opening the relays
   if(gFlags.relaysClosed){
      
      
      #ifdef DEBUG
         TERMIO_PutString("errorMode: opening the relays\n");
      #endif
   
      OpenRelays();
      gFlags.relaysClosed = 0;
   }
   

   if(gError.slaveTimeout){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: slave communication timeout error\n");
      #endif 
   } 
   
   if(gError.cellOpenConnection){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: cell open connection error\n");
      #endif
   }
   
   if(gError.cellMaxVolt){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: cell overvoltage error\n");
      #endif 
   }
   
   if(gError.cellMinVolt){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: cell undervoltage error\n");
      #endif
   }
   
   if(gError.cellMaxTemp){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: temperature too hot error\n");
      #endif
   }
    
   if(gError.cellMinTemp){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: temperature too cold error\n");
      #endif
   }
   
   if(gError.maxMeanDischargeCurrent){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: maximum mean current error\n");
      #endif
   }
   
   if(gError.maxPeakCurrent){
      #ifdef DEBUG
         if(gMode != gLastMode)   TERMIO_PutString("errorMode: maximum peak current error\n");
      #endif
   }
}
