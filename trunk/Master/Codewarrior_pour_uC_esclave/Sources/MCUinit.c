/*
** ###################################################################
**     This code is generated by the Device Initialization Tool.
**     It is overwritten during code generation.
**     USER MODIFICATION ARE PRESERVED ONLY INSIDE INTERRUPT SERVICE ROUTINES
**     OR EXPLICITLY MARKED SECTIONS
**
**     Project   : Master
**     Processor : MC9S12XDP512BMPV
**     Version   : Component 02.003, Driver 01.05, CPU db: 2.87.229
**     Datasheet : MC9S12XDP512RMV2 Rev. 2.18 May 2008
**     Date/Time : 15/06/2013, 1:03 PM
**     Abstract  :
**         This module contains device initialization code 
**         for selected on-chip peripherals.
**     Contents  :
**         Function "MCU_init" initializes selected peripherals
**
**     Copyright : 1997 - 2010 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################
*/
/* MODULE MCUinit */

#include <MC9S12XDP512.h>              /* I/O map for MC9S12XDP512BMPV */
#include "MCUinit.h"

/* Standard ANSI C types */
#ifndef int8_t
typedef signed char int8_t;
#endif
#ifndef int16_t
typedef signed int   int16_t;
#endif
#ifndef int32_t
typedef signed long int    int32_t;
#endif

#ifndef uint8_t
typedef unsigned char       uint8_t;
#endif
#ifndef uint16_t
typedef unsigned int  uint16_t;
#endif
#ifndef uint32_t
typedef unsigned long int   uint32_t;
#endif

#define CGM_DELAY  1023U

/* User declarations and definitions */
/*   Code, declarations and definitions here will be preserved during code generation */

#include <hidef.h>            /* common defines and macros */
#include "derivative.h"      /* derivative-specific definitions */
#include "terminal_code.h"
#include "can.h"
#include "defines.h"
#include "termio.h"
#include "relays.h"
#include <stdio.h>


/* End of user declarations and definitions */

extern void near _Startup(void);

#pragma CODE_SEG __NEAR_SEG NON_BANKED

static void MCU_init_reset(void);
/*
** ===================================================================
**     Method      :  MCU_init_reset (component MC9S12XDP512_112)
**
**     Description :
**         Device initialization code for after reset initialization.
** ===================================================================
*/
static void MCU_init_reset(void)
{

  /*  Initialization of memory configuration */
  /* MMCCTL1: EROMON=0,ROMHM=0,ROMON=1 */
  MMCCTL1 = 1U;                                      
  /* DIRECT: DP15=0,DP14=0,DP13=0,DP12=0,DP11=0,DP10=0,DP9=0,DP8=0 */
  DIRECT = 0U;                                      
  /* IVBR: IVB_ADDR=255 */
  IVBR = 255U;                                      
  /* ECLKCTL: NECLK=1,NCLKX2=1,EDIV1=0,EDIV0=0 */
  ECLKCTL = 192U;                                      
  /* Jump to the default entry point */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm jmp _Startup;
  /*lint -restore Enable MISRA rule (1.1) checking. */
} /*MCU_init*/

#pragma CODE_SEG DEFAULT
#pragma MESSAGE DISABLE C12056



/*
** ===================================================================
**     Method      :  MCU_init (component MC9S12XDP512_112)
**
**     Description :
**         Device initialization code for selected peripherals.
** ===================================================================
*/
void MCU_init(void)
{

  /* ### MC9S12XDP512_112 "Cpu" init code ... */
  /*  PE initialization code after reset */
  /*  System clock initialization */
  /* CLKSEL: PLLSEL=0,PSTP=0,PLLWAI=0,RTIWAI=0,COPWAI=0 */
  CLKSEL = 0U;                         /* Select clock source from XTAL and set bits in CLKSEL reg. */
  /* PLLCTL: CME=1,PLLON=0,AUTO=1,ACQ=1,FSTWKP=0,PRE=0,PCE=0,SCME=1 */
  PLLCTL = 177U;                       /* Disable the PLL */
  /* Initialization of RAM Protection (MMC module) */
  /* Int. priority initialization */
  /*                                        No. Address Pri XGATE Name          Description */
  INT_CFADDR = 16U;                                      
  INT_CFDATA1 = 1U;                    /*  0x09  0xFF12   1   no   ivReserved119 unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x0A  0xFF14   1   no   ivReserved118 unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x0B  0xFF16   1   no   ivReserved117 unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x0C  0xFF18   1   no   ivReserved116 unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x0D  0xFF1A   1   no   ivReserved115 unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x0E  0xFF1C   1   no   ivReserved114 unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x0F  0xFF1E   1   no   ivReserved113 unused by PE */
  INT_CFADDR = 32U;                                      
  INT_CFDATA0 = 1U;                    /*  0x10  0xFF20   1   no   ivReserved112 unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x11  0xFF22   1   no   ivReserved111 unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x12  0xFF24   1   no   ivReserved110 unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x13  0xFF26   1   no   ivReserved109 unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x14  0xFF28   1   no   ivReserved108 unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x15  0xFF2A   1   no   ivReserved107 unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x16  0xFF2C   1   no   ivReserved106 unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x17  0xFF2E   1   no   ivReserved105 unused by PE */
  INT_CFADDR = 48U;                                      
  INT_CFDATA0 = 1U;                    /*  0x18  0xFF30   1   no   ivReserved104 unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x19  0xFF32   1   no   ivReserved103 unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x1A  0xFF34   1   no   ivReserved102 unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x1B  0xFF36   1   no   ivReserved101 unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x1C  0xFF38   1   no   ivReserved100 unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x1D  0xFF3A   1   no   ivReserved99  unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x1E  0xFF3C   1   no   ivReserved98  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x1F  0xFF3E   1   no   ivReserved97  unused by PE */
  INT_CFADDR = 64U;                                      
  INT_CFDATA0 = 1U;                    /*  0x20  0xFF40   1   no   ivReserved96  unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x21  0xFF42   1   no   ivReserved95  unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x22  0xFF44   1   no   ivReserved94  unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x23  0xFF46   1   no   ivReserved93  unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x24  0xFF48   1   no   ivReserved92  unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x25  0xFF4A   1   no   ivReserved91  unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x26  0xFF4C   1   no   ivReserved90  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x27  0xFF4E   1   no   ivReserved89  unused by PE */
  INT_CFADDR = 80U;                                      
  INT_CFDATA0 = 1U;                    /*  0x28  0xFF50   1   no   ivReserved88  unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x29  0xFF52   1   no   ivReserved87  unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x2A  0xFF54   1   no   ivReserved86  unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x2B  0xFF56   1   no   ivReserved85  unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x2C  0xFF58   1   no   ivReserved84  unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x2D  0xFF5A   1   no   ivReserved83  unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x2E  0xFF5C   1   no   ivReserved82  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x2F  0xFF5E   1   no   ivReserved81  unused by PE */
  INT_CFADDR = 96U;                                      
  INT_CFDATA0 = 1U;                    /*  0x30  0xFF60   1   -    ivVxsramav    unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x31  0xFF62   1   -    ivVxsei       unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x32  0xFF64   1   no   ivVxst7       unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x33  0xFF66   1   no   ivVxst6       unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x34  0xFF68   1   no   ivVxst5       unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x35  0xFF6A   1   no   ivVxst4       unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x36  0xFF6C   1   no   ivVxst3       unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x37  0xFF6E   1   no   ivVxst2       unused by PE */
  INT_CFADDR = 112U;                                      
  INT_CFDATA0 = 1U;                    /*  0x38  0xFF70   1   no   ivVxst1       unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x39  0xFF72   1   no   ivVxst0       unused by PE */
  INT_CFDATA2 = 4U;                    /*  0x3A  0xFF74   4   no   ivVpit3       used by PE */
  INT_CFDATA3 = 2U;                    /*  0x3B  0xFF76   2   no   ivVpit2       used by PE */
  INT_CFDATA4 = 3U;                    /*  0x3C  0xFF78   3   no   ivVpit1       used by PE */
  INT_CFDATA5 = 2U;                    /*  0x3D  0xFF7A   2   no   ivVpit0       used by PE */
  INT_CFDATA6 = 1U;                    /*  0x3E  0xFF7C   1   no   ivVReserved65 unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x3F  0xFF7E   1   no   ivVapi        unused by PE */
  INT_CFADDR = 128U;                                      
  INT_CFDATA0 = 1U;                    /*  0x40  0xFF80   1   no   ivVlvi        unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x41  0xFF82   1   no   ivVReserved62 unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x42  0xFF84   1   no   ivVsci5       used by PE */
  INT_CFDATA3 = 1U;                    /*  0x43  0xFF86   1   no   ivVsci4       unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x44  0xFF88   1   no   ivVsci3       unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x45  0xFF8A   1   no   ivVsci2       unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x46  0xFF8C   1   no   ivVpwmesdn    used by PE */
  INT_CFDATA7 = 1U;                    /*  0x47  0xFF8E   1   no   ivVportp      unused by PE */
  INT_CFADDR = 144U;                                      
  INT_CFDATA0 = 1U;                    /*  0x48  0xFF90   1   no   ivVcan4tx     unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x49  0xFF92   1   no   ivVcan4rx     unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x4A  0xFF94   1   no   ivVcan4err    unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x4B  0xFF96   1   no   ivVcan4wkup   unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x4C  0xFF98   1   no   ivVcan3tx     unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x4D  0xFF9A   1   no   ivVcan3rx     unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x4E  0xFF9C   1   no   ivVcan3err    unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x4F  0xFF9E   1   no   ivVcan3wkup   unused by PE */
  INT_CFADDR = 160U;                                      
  INT_CFDATA0 = 1U;                    /*  0x50  0xFFA0   1   no   ivVcan2tx     unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x51  0xFFA2   1   no   ivVcan2rx     unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x52  0xFFA4   1   no   ivVcan2err    unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x53  0xFFA6   1   no   ivVcan2wkup   unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x54  0xFFA8   1   no   ivVcan1tx     used by PE */
  INT_CFDATA5 = 1U;                    /*  0x55  0xFFAA   1   no   ivVcan1rx     used by PE */
  INT_CFDATA6 = 1U;                    /*  0x56  0xFFAC   1   no   ivVcan1err    used by PE */
  INT_CFDATA7 = 1U;                    /*  0x57  0xFFAE   1   no   ivVcan1wkup   used by PE */
  INT_CFADDR = 176U;                                      
  INT_CFDATA0 = 1U;                    /*  0x58  0xFFB0   1   no   ivVcan0tx     used by PE */
  INT_CFDATA1 = 2U;                    /*  0x59  0xFFB2   2   no   ivVcan0rx     used by PE */
  INT_CFDATA2 = 1U;                    /*  0x5A  0xFFB4   1   no   ivVcan0err    used by PE */
  INT_CFDATA3 = 1U;                    /*  0x5B  0xFFB6   1   no   ivVcan0wkup   used by PE */
  INT_CFDATA4 = 1U;                    /*  0x5C  0xFFB8   1   no   ivVflash      unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x5D  0xFFBA   1   no   ivVeeprom     unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x5E  0xFFBC   1   no   ivVspi2       unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x5F  0xFFBE   1   no   ivVspi1       unused by PE */
  INT_CFADDR = 192U;                                      
  INT_CFDATA0 = 1U;                    /*  0x60  0xFFC0   1   no   ivViic0       unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x61  0xFFC2   1   no   ivVReserved30 unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x62  0xFFC4   1   no   ivVcrgscm     unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x63  0xFFC6   1   no   ivVcrgplllck  unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x64  0xFFC8   1   no   ivVtimpabovf  unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x65  0xFFCA   1   no   ivVtimmdcu    unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x66  0xFFCC   1   no   ivVporth      unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x67  0xFFCE   1   no   ivVportj      used by PE */
  INT_CFADDR = 208U;                                      
  INT_CFDATA0 = 1U;                    /*  0x68  0xFFD0   1   no   ivVatd1       used by PE */
  INT_CFDATA1 = 2U;                    /*  0x69  0xFFD2   2   no   ivVatd0       used by PE */
  INT_CFDATA2 = 1U;                    /*  0x6A  0xFFD4   1   no   ivVsci1       unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x6B  0xFFD6   1   no   ivVsci0       unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x6C  0xFFD8   1   no   ivVspi0       unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x6D  0xFFDA   1   no   ivVtimpaie    unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x6E  0xFFDC   1   no   ivVtimpaaovf  unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x6F  0xFFDE   1   no   ivVtimovf     unused by PE */
  INT_CFADDR = 224U;                                      
  INT_CFDATA0 = 1U;                    /*  0x70  0xFFE0   1   no   ivVtimch7     unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x71  0xFFE2   1   no   ivVtimch6     unused by PE */
  INT_CFDATA2 = 1U;                    /*  0x72  0xFFE4   1   no   ivVtimch5     unused by PE */
  INT_CFDATA3 = 1U;                    /*  0x73  0xFFE6   1   no   ivVtimch4     unused by PE */
  INT_CFDATA4 = 1U;                    /*  0x74  0xFFE8   1   no   ivVtimch3     unused by PE */
  INT_CFDATA5 = 1U;                    /*  0x75  0xFFEA   1   no   ivVtimch2     unused by PE */
  INT_CFDATA6 = 1U;                    /*  0x76  0xFFEC   1   no   ivVtimch1     unused by PE */
  INT_CFDATA7 = 1U;                    /*  0x77  0xFFEE   1   no   ivVtimch0     unused by PE */
  INT_CFADDR = 240U;                                      
  INT_CFDATA0 = 1U;                    /*  0x78  0xFFF0   1   no   ivVrti        unused by PE */
  INT_CFDATA1 = 1U;                    /*  0x79  0xFFF2   1   no   ivVirq        unused by PE */
  /* Common initialization of the CPU registers */
  /* MODRR: MODRR1=1,MODRR0=1 */
  MODRR |= (unsigned char)3U;                      
  /* COPCTL: WCOP=0,RSBCK=0,WRTMASK=0,CR2=0,CR1=0,CR0=0 */
  COPCTL = 0U;                                      
  /* PERP: PERP6=1,PERP5=1,PERP4=1,PERP3=1,PERP2=1,PERP1=1,PERP0=1 */
  PERP |= (unsigned char)127U;                      
  /* PERT: PERT3=1,PERT2=1,PERT1=1,PERT0=1 */
  PERT |= (unsigned char)15U;                      
  /* PERH: PERH5=1,PERH4=1,PERH3=1,PERH2=1,PERH1=1,PERH0=1 */
  PERH |= (unsigned char)63U;                      
  /* PER1AD0: PER1AD06=1,PER1AD05=1,PER1AD04=1,PER1AD03=1,PER1AD02=1,PER1AD01=1,PER1AD00=1 */
  PER1AD0 |= (unsigned char)127U;                      
  /* PER1AD1: PER1AD114=1,PER1AD113=1,PER1AD112=1,PER1AD111=1,PER1AD110=1,PER1AD19=1,PER1AD18=1 */
  PER1AD1 |= (unsigned char)127U;                      
  /* PERM: PERM5=1,PERM4=1,PERM1=1,PERM0=1 */
  PERM |= (unsigned char)51U;                      
  /* IRQCR: IRQEN=0 */
  IRQCR &= (unsigned char)~(unsigned char)64U;                     
  /* ### Init_SCI init code */
  /* SCI5BD: IREN=0,TNP1=0,TNP0=0,SBR12=0,SBR11=0,SBR10=0,SBR9=0,SBR8=0,SBR7=0,SBR6=0,SBR5=1,SBR4=1,SBR3=0,SBR2=1,SBR1=0,SBR0=0 */
  SCI5BD = 52U;                            
  /* SCI5CR2: TIE=0,TCIE=0,RIE=0,ILIE=0,TE=1,RE=1,RWU=0,SBK=0 */
  SCI5CR2 = 12U;                                      
  /* ### Init_PIT init code */
  /* PITMTLD1: PMTLD7=1,PMTLD6=1,PMTLD5=1,PMTLD4=1,PMTLD3=1,PMTLD2=1,PMTLD1=1,PMTLD0=1 */
  PITMTLD1 = 255U;                                      
  /* PITLD0: PLD15=0,PLD14=0,PLD13=0,PLD12=1,PLD11=1,PLD10=1,PLD9=1,PLD8=1,PLD7=0,PLD6=0,PLD5=1,PLD4=1,PLD3=1,PLD2=1,PLD1=1,PLD0=1 */
  PITLD0 = 7999U;                            
  /* PITLD1: PLD15=0,PLD14=0,PLD13=0,PLD12=1,PLD11=1,PLD10=1,PLD9=1,PLD8=1,PLD7=0,PLD6=0,PLD5=1,PLD4=1,PLD3=1,PLD2=1,PLD1=1,PLD0=1 */
  PITLD1 = 7999U;                            
  /* PITLD2: PLD15=0,PLD14=0,PLD13=0,PLD12=0,PLD11=0,PLD10=0,PLD9=0,PLD8=1,PLD7=0,PLD6=0,PLD5=1,PLD4=1,PLD3=1,PLD2=0,PLD1=0,PLD0=0 */
  PITLD2 = 312U;                            
  /* PITLD3: PLD15=0,PLD14=0,PLD13=0,PLD12=0,PLD11=0,PLD10=0,PLD9=0,PLD8=1,PLD7=0,PLD6=0,PLD5=1,PLD4=1,PLD3=0,PLD2=1,PLD1=1,PLD0=1 */
  PITLD3 = 311U;                            
  /* PITMUX: PMUX3=1,PMUX2=1,PMUX1=0,PMUX0=0 */
  PITMUX = 12U;                                      
  /* PITINTE: PINTE3=1,PINTE2=1,PINTE1=1,PINTE0=1 */
  PITINTE = 15U;                                      
  /* PITCFLMT: PITE=1,PITSWAI=0,PITFRZ=0,PFLMT1=0,PFLMT0=0 */
  PITCFLMT = 128U;                                      
  /* ### Init_ADC init code */
  /* Initialization of the ADC0 module */
  /* ATD0CTL3: S8C=1,S4C=0,S2C=0,S1C=0,FIFO=0,FRZ1=0,FRZ0=0 */
  ATD0CTL3 = 64U;                                      
  /* ATD0CTL4: SRES8=0,SMP1=1,SMP0=1,PRS4=0,PRS3=0,PRS2=1,PRS1=0,PRS0=1 */
  ATD0CTL4 = 101U;                                      
  /* ATD0CTL5: DJM=1,DSGN=0,SCAN=0,MULT=1,CC=0,CB=0,CA=0 */
  ATD0CTL5 = 144U;                                      
  /* ATD0CTL2: ADPU=0,AFFC=0,AWAI=0,ETRIGLE=0,ETRIGP=0,ETRIGE=0,ASCIE=1,ASCIF=0 */
  ATD0CTL2 = 2U;                                      
  /* ### Init_MSCAN init code */
  /* CAN0CTL1: CANE=1,CLKSRC=1,LOOPB=0,LISTEN=0,BORM=0,WUPM=0,SLPAK=0,INITAK=1 */
  CAN0CTL1 = 193U;                                      
  /* CAN0BTR1: SAMP=0,TSEG22=0,TSEG21=1,TSEG20=1,TSEG13=1,TSEG12=0,TSEG11=1,TSEG10=0 */
  CAN0BTR1 = 58U;                                      
  /* CAN0BTR0: SJW1=0,SJW0=1,BRP5=0,BRP4=0,BRP3=0,BRP2=0,BRP1=1,BRP0=1 */
  CAN0BTR0 = 67U;                                      
  /* CAN0IDAC: IDAM1=0,IDAM0=1,IDHIT2=0,IDHIT1=0,IDHIT0=0 */
  CAN0IDAC = 16U;                                      
  /* CAN0IDAR0: AC7=1,AC6=0,AC5=1,AC4=1,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN0IDAR0 = 176U;                                      
  /* CAN0IDMR0: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR0 = 255U;                                      
  /* CAN0IDMR1: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR1 = 255U;                                      
  /* CAN0IDMR2: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR2 = 255U;                                      
  /* CAN0IDMR3: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR3 = 255U;                                      
  /* CAN0IDMR4: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR4 = 255U;                                      
  /* CAN0IDMR5: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR5 = 255U;                                      
  /* CAN0IDMR6: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR6 = 255U;                                      
  /* CAN0IDMR7: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN0IDMR7 = 255U;                                      
  /* CAN0CTL0: INITRQ=0 */
  CAN0CTL0 &= (unsigned char)~(unsigned char)1U;                     
  while(CAN0CTL1_INITAK) {             /* Wait for init exit */
  }
  /* CAN0CTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=0 */
  CAN0CTL0 = 0U;                                      
  /* CAN0RIER: WUPIE=0,CSCIE=0,RSTATE1=0,RSTATE0=0,TSTATE1=0,TSTATE0=0,OVRIE=0,RXFIE=1 */
  CAN0RIER = 1U;                                      
  /* ### Init_PWM init code */
  /* PWMDTY7: BIT7=0,BIT6=1,BIT5=1,BIT4=1,BIT3=1,BIT2=1,BIT1=1,BIT0=1 */
  PWMDTY7 = 127U;                                      
  /* PWMPRCLK: PCKB2=0,PCKB1=0,PCKB0=0,PCKA2=1,PCKA1=1,PCKA0=1 */
  PWMPRCLK = 7U;                                      
  /* PWME: PWME7=1,PWME6=0,PWME5=0,PWME4=0,PWME3=0,PWME2=0,PWME1=0,PWME0=0 */
  PWME = 128U;                         /* Enable only configured PWM channels */
  /* ### Init_MSCAN init code */
  /* CAN1CTL1: CANE=1,CLKSRC=1,LOOPB=0,LISTEN=0,BORM=0,WUPM=0,SLPAK=0,INITAK=1 */
  CAN1CTL1 = 193U;                                      
  /* CAN1BTR1: SAMP=0,TSEG22=0,TSEG21=1,TSEG20=1,TSEG13=1,TSEG12=0,TSEG11=1,TSEG10=0 */
  CAN1BTR1 = 58U;                                      
  /* CAN1BTR0: SJW1=0,SJW0=1,BRP5=0,BRP4=0,BRP3=0,BRP2=0,BRP1=0,BRP0=0 */
  CAN1BTR0 = 64U;                                      
  /* CAN1IDAC: IDAM1=0,IDAM0=1,IDHIT2=0,IDHIT1=0,IDHIT0=0 */
  CAN1IDAC = 16U;                                      
  /* CAN1IDAR0: AC7=1,AC6=0,AC5=1,AC4=1,AC3=0,AC2=0,AC1=0,AC0=0 */
  CAN1IDAR0 = 176U;                                      
  /* CAN1IDMR0: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR0 = 255U;                                      
  /* CAN1IDMR1: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR1 = 255U;                                      
  /* CAN1IDMR2: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR2 = 255U;                                      
  /* CAN1IDMR3: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR3 = 255U;                                      
  /* CAN1IDMR4: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR4 = 255U;                                      
  /* CAN1IDMR5: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR5 = 255U;                                      
  /* CAN1IDMR6: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR6 = 255U;                                      
  /* CAN1IDMR7: AM7=1,AM6=1,AM5=1,AM4=1,AM3=1,AM2=1,AM1=1,AM0=1 */
  CAN1IDMR7 = 255U;                                      
  /* CAN1CTL0: INITRQ=0 */
  CAN1CTL0 &= (unsigned char)~(unsigned char)1U;                     
  while(CAN1CTL1_INITAK) {             /* Wait for init exit */
  }
  /* CAN1CTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=0 */
  CAN1CTL0 = 0U;                                      
  /* CAN1RIER: WUPIE=0,CSCIE=0,RSTATE1=0,RSTATE0=0,TSTATE1=0,TSTATE0=0,OVRIE=0,RXFIE=1 */
  CAN1RIER = 1U;                                      
  /* ### Init_GPIO init code */
  /* DDRA: DDRA5=1,DDRA4=1,DDRA3=1,DDRA2=1,DDRA1=1,DDRA0=1 */
  DDRA |= (unsigned char)63U;                      
  /* ### Init_GPIO init code */
  /* PPSM: PPSM6=1 */
  PPSM |= (unsigned char)64U;                      
  /* PERM: PERM7=1,PERM6=1 */
  PERM |= (unsigned char)192U;                      
  /* ### Init_GPIO init code */
  /* PTS: PTS4=1,PTS3=1 */
  PTS |= (unsigned char)24U;                      
  /* PPSS: PPSS6=1,PPSS5=1,PPSS2=1,PPSS1=1,PPSS0=1 */
  PPSS |= (unsigned char)103U;                      
  /* PERS: PERS7=0,PERS6=1,PERS5=1,PERS4=1,PERS3=1,PERS2=1,PERS1=1,PERS0=1 */
  PERS = 127U;                                      
  /* DDRS: DDRS7=1,DDRS6=1,DDRS5=0,DDRS4=0,DDRS3=0,DDRS2=0,DDRS1=0,DDRS0=0 */
  DDRS = 192U;                                      
  /* ### Init_GPIO init code */
  /* PTT: PTT7=1,PTT6=1,PTT5=1,PTT4=1 */
  PTT |= (unsigned char)240U;                      
  /* DDRT: DDRT7=1,DDRT6=1,DDRT5=1,DDRT4=1 */
  DDRT |= (unsigned char)240U;                      
  /* ### Init_ADC init code */
  /* Initialization of the ADC1 module */
  /* ### Init_GPIO init code */
  /* PTJ: PTJ1=1,PTJ0=1 */
  PTJ |= (unsigned char)3U;                      
  /* DDRJ: DDRJ1=1,DDRJ0=1 */
  DDRJ |= (unsigned char)3U;                      
  /* ### Init_GPIO init code */
  /* PORTK: PK5=1,PK4=1 */
  PORTK |= (unsigned char)48U;                      
  /* DDRK: DDRK5=1,DDRK4=1 */
  DDRK |= (unsigned char)48U;                      
  /* ### */
  /* Initial interrupt priority */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm {
    PSHA
    LDAA #0
    TFR A,CCRH
    PULA
    CLI                                /* Enable interrupts */
  };
  /*lint -restore Enable MISRA rule (1.1) checking. */
} /*MCU_init*/

#pragma MESSAGE DEFAULT C12056

/*lint -save  -e765 Disable MISRA rule (8.10) checking. */
#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isr_default
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isr_default(void)
{
  /* Write your interrupt code here ... */

}
/* end of isr_default */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT3_sci_continuous
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT3_sci_continuous(void)
{
   // Permet d'afficher les données en continue dans la console
   PITTF_PTF3 = 1;
   SCIprintStatData(gCellVolt, gCellTemp);
   /****************
   / Obsolète : l'affichage a été modifié
   /**********************
   char buf[80];
   int index;
   
   index = indexOf(gSxiDisplayNumModule);
   
   PITTF_PTF3 = 1; //clear le interrupt flag	
   
   //Interrupt for the user interface continuous refresh mode
   sprintf(buf, "Affichage des données en mode continu pour le module %d\n\r", gSciDisplayNumModule);
   SCIprintString(buf);
   SCIprintString("-------------------------------------------------------\n\r");

   sprintf(buf, "Nombre d'initialisations = %u\n\r", gSlaveReset[index]);
   SCIprintString(buf);

   sprintf(buf, "Révision du firmware = %u\n\r", gSlaveRev[index]);
   SCIprintString(buf);   
   sciGetCellsData(gCellVolt, gCellTemp, index);
   SCIprintString("\n\n\r");   
   //*/
}
/* end of iPIT3_sci_continuous */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT2_100Hz
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT2_100Hz(void)
{
    static uint16 ignitionHistory = 0;
    static uint16 interlockStateHistory = 0;
    static uint16 errRstHistory = 0;
    static uint16 imdStateHistory = 0;
	static uint16 errorRstDashHistory = 0;
    static uint8 adcCount = 0;
    uint16 curIgnition;
    uint16 curInterlockState;
    uint16 curErrRst;
    uint16 curImdState;
	uint16 curErrorRstDash;



    uint8 i = 0;
    static uint8 index = 0;
    static uint16 flashSequence;
	static uint8 totPackCount = 0;
	static uint8 idleTimerCount = 0;
    
    //On met à 0 le flag d'interruption du PIT2
    PITTF_PTF2 = 1;  

    
    //Mesure du COURANT à 10 Hz
    adcCount++;
    if(adcCount == CURRENT_MEASURE_PERIOD) {     
        //ATD0CTL5_CB = 1;                        //Démarrage de la séquence de conversion AN7 a AN15 (ADC0)
        //TODO: désactivé pour l'instant
        adcCount = 0;
    }
    
    
    //On détermine l'état de l'entrée IGNITION. On attend d'avoir reçu 5 valeurs (50 ms pour changer)
    //identiques avant de changer le drapeau.
    curIgnition = (uint16) IGNITION;
    ignitionHistory = ignitionHistory<<1;
    ignitionHistory = ignitionHistory | (curIgnition & 0x1);
    
    if((ignitionHistory & 0x1F) == 0x1F)      //On assume la logique normale, i.e. 1 = ignition ON
        gFlags.ignition = 1;
    else if((ignitionHistory & 0x1F) == 0)
        gFlags.ignition = 0;

            
    //On détermine l'état de l'entrée INTERLOCK STATE. On attend d'avoir reçu 5 valeurs (50 ms pour changer)
    //identiques avant de changer le drapeau.
    curInterlockState = (uint16) INTERLOCK_STATE;
    interlockStateHistory = interlockStateHistory<<1;
    interlockStateHistory = interlockStateHistory | (curInterlockState & 0x1);
    
    if((interlockStateHistory & 0x1F) == 0x1F)    //logique normale, i.e. 1 = interlock fermé
        gFlags.interlockClosed = 1;
    else if((interlockStateHistory & 0x1F) == 0) 
        gFlags.interlockClosed = 0;
    
	
	
	//On détermine l'état de l'entrée ERROR_RST_DASH. On attend d'avoir reçu 5 valeurs (50 ms pour changer)
    //identiques avant de changer le drapeau.
    curErrorRstDash = !((uint16) ERROR_RST_DASH); // ERROR_RST_DASH est à 0 s'il y a un problème
    errorRstDashHistory = errorRstDashHistory<<1;
    errorRstDashHistory = errorRstDashHistory | (curErrorRstDash & 0x1);
    
    if((errorRstDashHistory & 0x1F) == 0x1F)    //logique normale, i.e. 1 = interlock fermé
		gFlags.plausibilityLatch = 0;
	
	
	
	
    
    //On détermine l'état de l'entrée ERROR RESET. On attend d'avoir reçu 5 valeurs (50 ms pour changer)
    //identiques avant de changer le drapeau.
    curErrRst = (uint16) ERROR_RESET;
    errRstHistory = errRstHistory<<1;
    errRstHistory = errRstHistory | (curErrRst & 0x1);
    
    if((errRstHistory & 0x1F) == 0x1F)    //logique inverse, i.e. 0 = bouton pressé
        gFlags.errorReset = 0;
    else if((errRstHistory & 0x1F) == 0)
	{
		resetIgnoreTempTable(); // On réinitialise le tableau des températures ignorées
		resetIDtable(); // On réinitialise la table de correspondance
		gFlags.errorReset = 1;
	}


    //On détermine l'état de l'entrée IMD STATE. On attend d'avoir reçu 5 valeurs (50 ms pour changer)
    //identiques avant de changer le drapeau.
    curImdState = (uint16) IMD_STATE;
    imdStateHistory = imdStateHistory<<1;
    imdStateHistory = imdStateHistory | (curImdState & 0x1);
    
    if((imdStateHistory & 0x1F) == 0x1F)    //logique inverse, i.e. 0 = imd error
        gFlags.ImdError = 0;
    else if((imdStateHistory & 0x1F) == 0) 
        gFlags.ImdError = 1;
    
	 
	// AFFICHAGE 7 segments
	if(!gFlags.plausibilityLatch)
		display('P');
    else if(gFlags.errorState)
	{
		//Affichage du numéro de l'erreur selon l'erreur
		if(gError.cellMaxTemp)
			display(5);
		else if(gError.cellMaxVolt)
			display(7);
		else if(gError.cellMinVolt)
			display(8);
		else if(gError.cellMinTemp)
			display(6);
		else if(gError.slaveTimeout)
			display(9);
		else
			display('E');	
    }
	else if(gFlags.ImdError)
		display('F');
	else if(gFlags.cellHighTemp)
        display(1);
    else if(gFlags.cellLowVolt)
        display(4);
    else if(gFlags.cellHighVolt)
        display(3);
    else if(gFlags.cellLowTemp)
        display(2);
	else if(gFlags.relaysClosed)
		display('C');
    else
        display('A');
	
	// Point du 7 segment
	if(gFlags.interlockClosed)
        display(','); // Le point est éteint
	else
		display('.'); // Le point est allumé
	
	
	   // ----------------- LED sur le tableau de bord -----------------
		if(flashSequence > FLASH_LED_PERIOD)
		{
			flashSequence = 0;
		}
	   
		if(!gFlags.interlockClosed)
		{
			flashSequence++;
			//Clignotte si l'interlock est ouvert
			if(flashSequence < (FLASH_LED_PERIOD / 2))
				WARNING_DASH_LED = 0; //On éteint
			else
				WARNING_DASH_LED = 1; //On allume
		}
		else if (gFlags.errorState)
			WARNING_DASH_LED = 1; //Allumée en cas d'erreur
		else
			WARNING_DASH_LED = 0; //Éteinte
       
	   
	
	// Timer pour mesurer l'activité des esclaves   
   idleTimerCount++;
   if(idleTimerCount >= IDLE_TIMER_COUNT_PERIOD) {
      for(i=0; i<N_MOD; ++i) {
         if(idleCount[i] < COM_IDLE_COUNT_MAX)
            idleCount[i]++;
      }
      idleTimerCount = 0;
   }

   // Timer pour ... (je ne sais pas, à vérifier)
   totPackCount++;
   if(totPackCount >= PACK_VOLT_CALC_PERIOD ) {
      gFlags.totalPackTime = 1;
      totPackCount = 0;
   }
   
}
/* end of iPIT2_100Hz */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT1_safety_check
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT1_safety_check(void)
{
   uint8 i;
   uint16 anyError = 0;
   uint16 tmp;
   long int highCurrent, maxCurrent;
   static uint16 delayMinVolt = 0;
    
   PITTF_PTF1 = 1;     //remise à zéro du flag, pour redémarrer le compteur.


   //------------- INSPECTION DES TENSIONS EXTRÊMES ------------- 
   
   gFlags.cellLowVolt = *gLowestCellVoltage < gParams.lowCellVoltage;
   gError.cellMinVolt = *gLowestCellVoltage < gParams.minCellVoltage;
   gFlags.cellHighVolt = *gHighestCellVoltage > gParams.highCellVoltage;
   gError.cellMaxVolt = *gHighestCellVoltage > gParams.maxCellVoltage;
   
   
   //----------- PATCH : Délai avant de déclencher une erreur cellMinVolt
   // L'accélération du véhicule provoque une diminution momentanée de la tension aux bornes des cellues du au courant sortant. Il ne faut pas
   // que le BMS tombe en erreur lors d'une accélération. On ajoute donc un délai.
   
   if(gError.cellMinVolt)
   {
		if(delayMinVolt < DELAI_CELLMINVOLT)
		{
			gError.cellMinVolt = 0; //on ignore l'erreur
			delayMinVolt++;
		}
   }
   else
   {
		delayMinVolt = 0; //on remet le compteur à 0
   }
   
  
   
   //------------- INSPECTION DES TEMPÉRATURES EXTRÊMES ------------- 
   
   if(!gFlags.charging) {
      gError.cellMinTemp = *gLowestCellTemp < gParams.minDischargeCellTemp;
      gFlags.cellLowTemp = *gLowestCellTemp < gParams.lowDischargeCellTemp;
      gError.cellMaxTemp = *gHighestCellTemp > gParams.maxDischargeCellTemp;
      gFlags.cellHighTemp = *gHighestCellTemp > gParams.highDischargeCellTemp;
   } else {
      gError.cellMinTemp = *gLowestCellTemp < gParams.minChargeCellTemp;
      gFlags.cellLowTemp = *gLowestCellTemp < gParams.lowChargeCellTemp;
      gError.cellMaxTemp = *gHighestCellTemp > gParams.maxChargeCellTemp;
      gFlags.cellHighTemp = *gHighestCellTemp > gParams.highChargeCellTemp;
   }
   
   
   
   //------------- VÉRIFICATION DES DÉLAIS DE COMMUNICATION ------------- 
    
   for(i=0; i<N_MOD; ++i) {
      tmp = (1<<i);
      if(idleCount[i] >= COM_IDLE_COUNT_MAX) {
         gSlaveComState = gSlaveComState | tmp;    // Il y a un slave de déconnecté
         gError.slaveTimeout = 1;
      } else {
         gSlaveComState = gSlaveComState & ~tmp;
      }
   }

   if(!gSlaveComState)
      gError.slaveTimeout = 0;   //Il n'y a plus de retard dans les comm.

    
   //---------------- INSPECTION DE LA MESURE DE COURANT ----------------
    
   // if(!gFlags.charging) {
      // //En décharge
      // highCurrent = gParams.highPeakDischargeCurrent;
      // maxCurrent = gParams.maxPeakDischargeCurrent;
      // gFlags.highPeakCurrent = (gMeanCurrent > highCurrent) || (gMeanCurrent < -highCurrent);
      // gError.maxPeakCurrent = (gMeanCurrent > maxCurrent) || (gMeanCurrent < -maxCurrent);
        
   // } else {
      // //En charge
      // maxCurrent = gParams.maxMeanChargeCurrent;
      // gError.maxPeakCurrent = (gMeanCurrent > maxCurrent) || (gMeanCurrent < -maxCurrent);
   //}                     
   
    gError.maxPeakCurrent = 0;
    gFlags.highPeakCurrent = 0;
    gError.maxMeanCurrent = 0;   //TODO: quoi faire avec le courant moyen?

    
    
   //--------------- CAS: OUVERTURE DE L'INTERLOCK LORSQUE RELAIS FERMÉS ----------------
   if(!gFlags.interlockClosed && gFlags.relaysClosed && !gParams.ignoreIntState)
      OpenRelays();
 
      //TODO: considérer interlock ouvert comme une erreur du BMS. Doit être resetté par switch.
      
   
   //--------------- GESTION DES ERREURS ----------------
   
   anyError = *((uint16*) &gError);

   if(anyError || gFlags.ImdError || !gFlags.plausibilityLatch) {   //Erreurs qui requiert le signal errorReset pour être remises à zéro
      gFlags.errorState = 1;
      if(gFlags.relaysClosed && !gParams.ignoreErrors)
         OpenRelays();
      
   } else {
      if(gFlags.errorState && gFlags.errorReset)
         gFlags.errorState = 0;
   }


}
/* end of iPIT1_safety_check */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iPIT0_timer_relais
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iPIT0_timer_relais(void)
{
   static unsigned int timeoutCount = 0;

   timeoutCount++;
   if(timeoutCount >= gTimerLimit) {
      PITCE_PCE0 = 0;   //désactivation du timer
      timeoutCount = 0;
      gTimerLimit = 0;
      CloseRelays(CONTINUE_SEQUENCE);  //à la fin du délai, on rappelle CloseRelays().
   }                                   //On ne reste pas dans cette fonction longtemps.
                                       //Soit la séquence de fermeture est terminée
                                       //soit on repart un nouveau délai.
   
   PITTF_PTF0 = 1;   //remise à zéro du flag
}
/* end of iPIT0_timer_relais */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : SCIIsr
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void SCIIsr(void)
{

   if (!(SCI5SR1 & 0x20))              //If reception flag is not set
      return;

   if(gGuiBufferFull)
      return;
	  
   gGuiBuffer[gGuiWriteIndex] = SCI5DRL;  //enregistrement du byte reçu + clear le reception flag
   
   gGuiWriteIndex++;
   if(gGuiWriteIndex > GUI_RX_BUFFER_SIZE)
      gGuiWriteIndex = 0;
   
   if(gGuiWriteIndex == gGuiReadIndex)    //Le buffer circulaire est plein. On a rattrapé la lecture.
      gGuiBufferFull = 1;
} 

/* end of SCIIsr */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVpwmesdn
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVpwmesdn(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVpwmesdn */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan1tx
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan1tx(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan1tx */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iCAN1RX_reception
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iCAN1RX_reception(void)
{
   uint8 length, indexRx, rxId, i=0;
   uint8 rxData[8];
     
   rxId = ((uint16) CAN1RXIDR0) << 3 | ((uint16) CAN1RXIDR1) >> 5;	//Récupération de l'id du packet
    
   //on récupère la longueur du message (8 octets max) 
	length = CAN1RXDLR;
      
    //le buffer de réception est de type FIFO et est long de 15 octets
	 for(indexRx=0; indexRx<length; indexRx++)
  	    rxData[indexRx] = *(&CAN1RXDSR0 + indexRx); //on récupère les données	  
      
	 //pour lever l'interruption et relâcher le buffer de réception foregroung
    CAN1RFLG_RXF = 1; 
}
/* end of iCAN1RX_reception */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan0err
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan0err(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan0err */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan0wkup
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan0wkup(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan0wkup */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVcan0tx
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVcan0tx(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVcan0tx */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iCANRX_reception
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iCANRX_reception(void)
{
   uint16 rxId; 
   uint8 length, slaveId, msgId;
   uint8 indexJump, i, j;
   uint8 rxData[8];
   uint16 rcvVolt;
   int rcvTemp, tempMoy;
   uint16 balVector, balThres, tmp;
   uint8 ignoreTemp, nbIgnore; // pour le patch qui ignore les températures  
   int index;	
	 
   rxId = ((uint16) CAN0RXIDR0) << 3 | ((uint16) CAN0RXIDR1) >> 5;	//Récupération de l'id du packet
   slaveId = (rxId & 0x3C0)>>6;			//Récupérer le ID de l'esclave source du message
   length = CAN0RXDLR; 					//on récupère la longueur du message (8 octets max)
   msgId = (rxId & 0x3F);           //Récupération de l'identificateur des données du message

   #ifdef DEBUG_CAN
	if(can_debug)
	{
	SCIprintString("[DEBUG] CAN : Reception d'un paquet\n\r");
	SCIprintInt(" Packet ID :", rxId);
	SCIprintInt(" Slave ID : ", slaveId);
	SCIprintInt(" Msg ID : ", msgId);
	SCIprintString(" (");
	}
   #endif
   
   // index pour les tableaux
   index = indexOf(slaveId);
  
   if(index == -1) // Si l'index n'existe pas déjà
   {
		index = addId(slaveId); // On l'ajoute et on récupère l'index qui lui est attribué
   }
   
    //le buffer de réception est de type FIFO et est long de 15 octets
   for (i=0; i<length; i++)
      rxData[i] = *(&CAN0RXDSR0 + i); //on récupère les données
	
    
   //Il y a de la vie dans ce module esclave
   if(idleCount[index] > 0)
      idleCount[index]--;

      
   //RÉCEPTION DES MESURES DE TENSIONS
   if(msgId == CAN_VOLTAGES_1TO4_ID  ||  msgId == CAN_VOLTAGES_5TO8_ID  ||  msgId == CAN_VOLTAGES_9TO10_ID) {  
   
	#ifdef DEBUG_CAN
	if(can_debug)
		SCIprintString("Reception de tensions)\n\r");
	#endif
      //On détermine le décalage de l'index nécessaire selon les données reçues
      if(msgId == CAN_VOLTAGES_1TO4_ID)
         indexJump = 0;
      else if(msgId == CAN_VOLTAGES_5TO8_ID)
         indexJump = 4;
      else
         indexJump = 8;
      
      //Pour chaque mesure, on l'écrit dans le tableau des tensions et on vérifie si c'est un nouvel extrême
      for(i=0; i<(length>>1); i++) {
         rcvVolt = (((unsigned int) rxData[2*i]) << 8) | rxData[2*i+1];
         gCellVolt[index][i+indexJump] = rcvVolt;
		 
		 
         //Mettre à jour les pointeurs vers les tensions extrêmes
         if(rcvVolt < *gLowestCellVoltage) {
            gLowestCellVoltage = &gCellVolt[index][i+indexJump];
            gLowestVoltageCellSlaveId = slaveId;
            gLowestVoltageCellNum = i+indexJump;
         } else if(rcvVolt > *gHighestCellVoltage) {
            gHighestCellVoltage = &gCellVolt[index][i+indexJump];
            gHighestVoltageCellSlaveId = slaveId;
            gHighestVoltageCellNum = i+indexJump;
         }
		 
		 //*
		 #ifdef DEBUG_CAN_1
			// Affichage des données de Tension reçues dans la console
			SCIprintInt(" Cellule #", i+indexJump);
			SCIprintInt(" Tension : ", (int)rcvVolt);
			SCIprintString(" mV\n\r");
		#endif
		//*/
      }
   } //end of received voltage measurements msg
   
 
 
   //RÉCEPTION DES MESURES DE TEMPÉRATURE   
   else if(  msgId == CAN_TEMP_1TO4_ID  ||  msgId == CAN_TEMP_5TO8_ID  ||  msgId == CAN_TEMP_9TO10_ID) {  
   
	#ifdef DEBUG_CAN
	if(can_debug)
		SCIprintString("Reception de temperatures)\n\r");
	#endif
	
      //On détermine le décalage de l'index nécessaire selon les données reçues
      if(msgId == CAN_TEMP_1TO4_ID)
         indexJump = 0;
      else if(msgId == CAN_TEMP_5TO8_ID)
         indexJump = 4;
      else
         indexJump = 8;

      //Pour chaque mesure, on l'écrit dans le tableau des temp. et on vérifie si c'est un nouvel extrême
      for(i=0; i<(length>>1); i++) {
         rcvTemp = (((unsigned int) rxData[2*i]) << 8) | rxData[2*i+1];

		 
		 
		//------------ PATCH : Ignorer certaines sondes de températures si les autres adjacentes indiquent une température OK
		// Certaines sondes de températures sont brisées ou mal positionnées ce qui peur causer des erreurs de basse température. 
		// Ce patch permet d'ignorer certaines températures si les sondes adjacentes indiquent une température dans les normes.
		// 
		// Note : Selon les règlements, on ne doit que vérifier la température de 40% (à vérifier) des cellules de façon uniforme. On peut donc
		//        se permettre d'en ignorer quelques unes.
		//
		// Le tableau de température a 2 dimensions : gCellTemp[N_MOD][N_CELL]
		// Pour ce patch, on crée un nouveau tableau contenant le numéro du module et le numéro de cellule de la sonde à ignorer : gCellIgnoreTemp
		ignoreTemp = 0;

		if(rcvTemp < gParams.minDischargeCellTemp || rcvTemp > gParams.maxDischargeCellTemp)
		{
		#ifdef DEBUG_CAN_1
			SCIprintString("[DEBUG] : Température à ignorer");
			SCIprintInt(":", rcvTemp);
			SCIprintString("\n\r");
		#endif
		
			// On vérifie qu'on ignore pas déjà la température
			for(j = 0; j < N_MAX_IGNORE_TEMP; j++)
			{
				if(gCellIgnoreTemp[j][0] == slaveId)
					if(gCellIgnoreTemp[j][1] == (i+indexJump))
						ignoreTemp = 1; // Si c'est le cas, on ignore sans ajouter une nouvelle entrée
				else if(gCellIgnoreTemp[j][0] == -1)
				{
					nbIgnore = j; //Nombre de sondes ignorées dans le tableau
					break; //inutile de continuer à chercher
				}
			}
		
			// Si la sonde n'est pas déjà ignorée
			if(ignoreTemp == 0)
			{
				//moyenne de température des 2 sondes adjacentes
				if(i+indexJump == 0)
					tempMoy = (gCellTemp[index][i+indexJump+1] + gCellTemp[index][i+indexJump+2]) / 2;
				else if(i+indexJump == 9)
					tempMoy = (gCellTemp[index][i+indexJump-1] + gCellTemp[index][i+indexJump-2]) / 2;
				else
					tempMoy = (gCellTemp[index][i+indexJump-1] + gCellTemp[index][i+indexJump+1]) / 2;
			
			
				// Valeur absolue de l'écart, on ignore si l'écart est assez grand
				if((tempMoy - rcvTemp) > 0)
					ignoreTemp = (tempMoy - rcvTemp) > ECART_MIN_TEMP; 
				else
					ignoreTemp = (rcvTemp - tempMoy) > ECART_MIN_TEMP;
			
			
				//Si on a bel et bien décidé d'ignorer la température
				if(ignoreTemp == 1)
				{
					//On ajoute la sonde à ignorer à la liste
					gCellIgnoreTemp[nbIgnore][0] = slaveId;
					gCellIgnoreTemp[nbIgnore][1] = i+indexJump;
				}
			}
		}
   
		 
		 // Ancien patch des sondes de températures
		 /*
         if(slaveId == 1 && (i+indexJump) == 9)     
            rcvTemp = 210;        //PATCH pour cellule 10 de l'esclave 1 (thermistor brûlé)
         else if(slaveId == 6 && (i+indexJump) == 9)
            rcvTemp = 210;        //PATCH pour cellule 10 de l'esclave 6 (entrée ADC non fonctionnelle)
		*/
		
//*	
		#ifdef DEBUG_CAN_1
			// Affichage des données de Température reçues dans la console
			SCIprintInt(" Cellule #", i+indexJump);
			SCIprintInt(" Temp : ", (int)(rcvTemp*10));
			SCIprintString(" oC\n\r");
		#endif
		//*/ 
        
		gCellTemp[index][i+indexJump] = rcvTemp;
        
		
         //Mettre à jour les pointeurs vers les températures extrêmes si la température n'est pas ignorée
         if(rcvTemp < *gLowestCellTemp && ignoreTemp == 0) {
            gLowestCellTemp = &gCellTemp[index][i+indexJump];
            gLowestTempCellSlaveId = slaveId;
            gLowestTempCellNum = i+indexJump;
         } else if(rcvTemp > *gHighestCellTemp && ignoreTemp == 0) {
            gHighestCellTemp = &gCellTemp[index][i+indexJump];
            gHighestTempCellSlaveId = slaveId;
            gHighestTempCellNum = i+indexJump;
         }
      }
   } //fin de message de réception de températures
 
 
   //RÉCEPTION D'UN RAPPORT D'ÉQUILIBRATION  
   else if(msgId == CAN_EQUI_REPORT_ID) {
	 
	#ifdef DEBUG_CAN
	if(can_debug)
		SCIprintString("Rapport d'equilibration)\n\r");
	#endif
	
	  balVector = ((unsigned int) rxData[0])<<8 | ((unsigned int) rxData[1]);
      balThres = ((unsigned int) rxData[2])<<8 | ((unsigned int) rxData[3]);
      
      if(balVector == 0) {
         tmp = 1<<(slaveId-1);
         gSlaveEquiStatus = (gSlaveEquiStatus & ~tmp);
         
         if((gSlaveEquiStatus == 0) && gFlags.equilibrating)
            gFlags.equilibrating = 0;
      }
   }
   
   //RÉCEPTION D'UN RAPPORT D'INITIALISATION
   else if (msgId == CAN_INIT_REPORT_ID) {
	
	#ifdef DEBUG_CAN
    if(can_debug)
		SCIprintString("Rapport d'initialisation)\n\r");
	#endif
	
       gSlaveReset[index]++;
   }
   
   //RÉCEPTION D'UN RAPPORT DE NUMÉRO DE FIRMWARE
   else if(msgId == CAN_FIRMWARE_REVISION_ID) {
   
	
	#ifdef DEBUG_CAN
	if(can_debug)
		SCIprintString("Numero de Firmware)\n\r");
	#endif
	
	
       gSlaveRev[index] = rxData[0];
	}
	#ifdef DEBUG_CAN
	else
	{
		SCIprintString("Inconnu)\n\r");
	}
	#endif

   
	//pour lever l'interruption et relâcher le buffer de réception foreground
    CAN0RFLG_RXF = 1; 
}
/* end of iCANRX_reception */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVportj
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVportj(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVportj */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVatd1
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVatd1(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVatd1 */
#pragma CODE_SEG DEFAULT


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : iADC_sequence_complete
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void iADC_sequence_complete(void)
{
	long int lastCurrent;

    
    //***************************************************************************
    //                    LISTE DES SIGNAUX ANALOGIQUES CONVERTIS
    //
    // Signal du CAPTEUR DE COURANT CHANNEL 1 (-30 à 30 A) sur le channel AN15 de
    // l'ADC0. La mesure se retrouve dans le registre ATD0DR8.
    //
    // Signal du CAPTEUR DE COURANT CHANNEL 2 (-350 à 350 A) sur le channel AN7 de
    // l'ADC0. La mesure se retrouve dans le registre ATD0DR0.
    //***************************************************************************

    //***************************************************************************
    //                           CALCUL DU COURANT
    //
    // La formule pour convertir le résultat numérique N de l'ADC en courant I (mA)
    // est la suivante:
    //                      I = (5x10^6/4096/G) * (N-2048) = K_HALL * (N-2048)
    //
    // où G est la sensibilité du capteur en mV/A. Pour le channel 1, G = 66.7 mV/A.
    // Pour le channel 2, G = 5.7 mV/A. Ces valeurs sont précises pour VCC = 5V.
    //
    // Les valeurs de K_HALL sont multipliées par 128 pour garder plus de précision
    // et éviter une multiplication en point flottant.
      //***************************************************************************
  
  
    // Si le résultat du channel 1 est supérieur à 4.5V, ou inférieur à 0.5V, on considère
    // qu'il est saturé, et on prend la mesure sur le channel 2. Le capteur ne peut nous
    // retourner une tension inférieure à 0.25V ou supérieur à 4.75V. On garde une marge
    // de 0.25V.
    //if((ATD0DR8 < 410) || (ATD0DR8 > 3686))
        //lastCurrent = ((long int)ATD0DR0 - (long int)2048)*K_HALL2;
    //else  
        //lastCurrent = ((long int)ATD0DR8 - (long int)2048)*K_HALL1;

    lastCurrent = 0;
    lastCurrent = lastCurrent>>7;           //On divise le résultat par 128 parce qu'on a multiplié K_HALL par 128
  
    //On tient une moyenne mobile exponentielle sur le courant
    //xt_moy = alpha*xt + (1-alpha)*xt-1_moy,  alpha = 2/(N+1)
    //Le coefficient de lissage alpha est égal à 0.125 ce qui veut dire
    //que les 15 dernières mesures portent 86% du poids de la moyenne.
    //À 100 ms/mesure, c'est une moyenne sur 1.5 secondes.
    gMeanCurrent = lastCurrent + (8-1)*gMeanCurrent;
    gMeanCurrent = gMeanCurrent>>3;


    //raz du flag (pas le choix si on veut sortir de l'interrupt)
    ATD0STAT0_SCF = 1;
}
/* end of iADC_sequence_complete */
#pragma CODE_SEG DEFAULT


/*lint -restore Enable MISRA rule (8.10) checking. */

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
/* Initialization of the CPU registers in FLASH */
/*lint -restore Enable MISRA rule (1.1) checking. */




/* Interrupt vector table */


/* ISR prototype */
typedef void (*near tIsrFunc)(void);

#ifndef UNASSIGNED_ISR
  #define UNASSIGNED_ISR isr_default   /* unassigned interrupt service routine */
#endif
/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
static const tIsrFunc _InterruptVectorTable[] @0xFF10U = { /* Interrupt vector table */
/*lint -restore Enable MISRA rule (1.1) checking. */
  /* ISR name                               No.  Address Pri XGATE Name          Description */
  &UNASSIGNED_ISR,                      /* 0x08  0xFF10   -   -    ivVsi         unused by PE */
  &UNASSIGNED_ISR,                      /* 0x09  0xFF12   1   no   ivReserved119 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0A  0xFF14   1   no   ivReserved118 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0B  0xFF16   1   no   ivReserved117 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0C  0xFF18   1   no   ivReserved116 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0D  0xFF1A   1   no   ivReserved115 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0E  0xFF1C   1   no   ivReserved114 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x0F  0xFF1E   1   no   ivReserved113 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x10  0xFF20   1   no   ivReserved112 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x11  0xFF22   1   no   ivReserved111 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x12  0xFF24   1   no   ivReserved110 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x13  0xFF26   1   no   ivReserved109 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x14  0xFF28   1   no   ivReserved108 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x15  0xFF2A   1   no   ivReserved107 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x16  0xFF2C   1   no   ivReserved106 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x17  0xFF2E   1   no   ivReserved105 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x18  0xFF30   1   no   ivReserved104 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x19  0xFF32   1   no   ivReserved103 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1A  0xFF34   1   no   ivReserved102 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1B  0xFF36   1   no   ivReserved101 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1C  0xFF38   1   no   ivReserved100 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1D  0xFF3A   1   no   ivReserved99  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1E  0xFF3C   1   no   ivReserved98  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x1F  0xFF3E   1   no   ivReserved97  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x20  0xFF40   1   no   ivReserved96  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x21  0xFF42   1   no   ivReserved95  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x22  0xFF44   1   no   ivReserved94  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x23  0xFF46   1   no   ivReserved93  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x24  0xFF48   1   no   ivReserved92  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x25  0xFF4A   1   no   ivReserved91  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x26  0xFF4C   1   no   ivReserved90  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x27  0xFF4E   1   no   ivReserved89  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x28  0xFF50   1   no   ivReserved88  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x29  0xFF52   1   no   ivReserved87  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2A  0xFF54   1   no   ivReserved86  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2B  0xFF56   1   no   ivReserved85  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2C  0xFF58   1   no   ivReserved84  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2D  0xFF5A   1   no   ivReserved83  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2E  0xFF5C   1   no   ivReserved82  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x2F  0xFF5E   1   no   ivReserved81  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x30  0xFF60   1   -    ivVxsramav    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x31  0xFF62   1   -    ivVxsei       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x32  0xFF64   1   no   ivVxst7       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x33  0xFF66   1   no   ivVxst6       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x34  0xFF68   1   no   ivVxst5       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x35  0xFF6A   1   no   ivVxst4       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x36  0xFF6C   1   no   ivVxst3       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x37  0xFF6E   1   no   ivVxst2       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x38  0xFF70   1   no   ivVxst1       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x39  0xFF72   1   no   ivVxst0       unused by PE */
  &iPIT3_sci_continuous,                /* 0x3A  0xFF74   4   no   ivVpit3       used by PE */
  &iPIT2_100Hz,                         /* 0x3B  0xFF76   2   no   ivVpit2       used by PE */
  &iPIT1_safety_check,                  /* 0x3C  0xFF78   3   no   ivVpit1       used by PE */
  &iPIT0_timer_relais,                  /* 0x3D  0xFF7A   2   no   ivVpit0       used by PE */
  &UNASSIGNED_ISR,                      /* 0x3E  0xFF7C   1   no   ivVReserved65 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x3F  0xFF7E   1   no   ivVapi        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x40  0xFF80   1   no   ivVlvi        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x41  0xFF82   1   no   ivVReserved62 unused by PE */
  &SCIIsr,                              /* 0x42  0xFF84   1   no   ivVsci5       used by PE */
  &UNASSIGNED_ISR,                      /* 0x43  0xFF86   1   no   ivVsci4       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x44  0xFF88   1   no   ivVsci3       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x45  0xFF8A   1   no   ivVsci2       unused by PE */
  &isrVpwmesdn,                         /* 0x46  0xFF8C   1   no   ivVpwmesdn    used by PE */
  &UNASSIGNED_ISR,                      /* 0x47  0xFF8E   1   no   ivVportp      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x48  0xFF90   1   no   ivVcan4tx     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x49  0xFF92   1   no   ivVcan4rx     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4A  0xFF94   1   no   ivVcan4err    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4B  0xFF96   1   no   ivVcan4wkup   unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4C  0xFF98   1   no   ivVcan3tx     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4D  0xFF9A   1   no   ivVcan3rx     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4E  0xFF9C   1   no   ivVcan3err    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x4F  0xFF9E   1   no   ivVcan3wkup   unused by PE */
  &UNASSIGNED_ISR,                      /* 0x50  0xFFA0   1   no   ivVcan2tx     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x51  0xFFA2   1   no   ivVcan2rx     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x52  0xFFA4   1   no   ivVcan2err    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x53  0xFFA6   1   no   ivVcan2wkup   unused by PE */
  &isrVcan1tx,                          /* 0x54  0xFFA8   1   no   ivVcan1tx     used by PE */
  &iCAN1RX_reception,                   /* 0x55  0xFFAA   1   no   ivVcan1rx     used by PE */
  &isrVcan0err,                         /* 0x56  0xFFAC   1   no   ivVcan1err    used by PE */
  &isrVcan0wkup,                        /* 0x57  0xFFAE   1   no   ivVcan1wkup   used by PE */
  &isrVcan0tx,                          /* 0x58  0xFFB0   1   no   ivVcan0tx     used by PE */
  &iCANRX_reception,                    /* 0x59  0xFFB2   2   no   ivVcan0rx     used by PE */
  &isrVcan0err,                         /* 0x5A  0xFFB4   1   no   ivVcan0err    used by PE */
  &isrVcan0wkup,                        /* 0x5B  0xFFB6   1   no   ivVcan0wkup   used by PE */
  &UNASSIGNED_ISR,                      /* 0x5C  0xFFB8   1   no   ivVflash      unused by PE */
  &UNASSIGNED_ISR,                      /* 0x5D  0xFFBA   1   no   ivVeeprom     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x5E  0xFFBC   1   no   ivVspi2       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x5F  0xFFBE   1   no   ivVspi1       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x60  0xFFC0   1   no   ivViic0       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x61  0xFFC2   1   no   ivVReserved30 unused by PE */
  &UNASSIGNED_ISR,                      /* 0x62  0xFFC4   1   no   ivVcrgscm     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x63  0xFFC6   1   no   ivVcrgplllck  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x64  0xFFC8   1   no   ivVtimpabovf  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x65  0xFFCA   1   no   ivVtimmdcu    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x66  0xFFCC   1   no   ivVporth      unused by PE */
  &isrVportj,                           /* 0x67  0xFFCE   1   no   ivVportj      used by PE */
  &isrVatd1,                            /* 0x68  0xFFD0   1   no   ivVatd1       used by PE */
  &iADC_sequence_complete,              /* 0x69  0xFFD2   2   no   ivVatd0       used by PE */
  &UNASSIGNED_ISR,                      /* 0x6A  0xFFD4   1   no   ivVsci1       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6B  0xFFD6   1   no   ivVsci0       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6C  0xFFD8   1   no   ivVspi0       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6D  0xFFDA   1   no   ivVtimpaie    unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6E  0xFFDC   1   no   ivVtimpaaovf  unused by PE */
  &UNASSIGNED_ISR,                      /* 0x6F  0xFFDE   1   no   ivVtimovf     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x70  0xFFE0   1   no   ivVtimch7     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x71  0xFFE2   1   no   ivVtimch6     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x72  0xFFE4   1   no   ivVtimch5     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x73  0xFFE6   1   no   ivVtimch4     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x74  0xFFE8   1   no   ivVtimch3     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x75  0xFFEA   1   no   ivVtimch2     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x76  0xFFEC   1   no   ivVtimch1     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x77  0xFFEE   1   no   ivVtimch0     unused by PE */
  &UNASSIGNED_ISR,                      /* 0x78  0xFFF0   1   no   ivVrti        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x79  0xFFF2   1   no   ivVirq        unused by PE */
  &UNASSIGNED_ISR,                      /* 0x7A  0xFFF4   -   -    ivVxirq       unused by PE */
  &UNASSIGNED_ISR,                      /* 0x7B  0xFFF6   -   -    ivVswi        unused by PE */
  &UNASSIGNED_ISR                       /* 0x7C  0xFFF8   -   -    ivVtrap       unused by PE */
};

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
static const tIsrFunc _ResetVectorTable[] @0xFFFAU = { /* Reset vector table */
/*lint -restore Enable MISRA rule (1.1) checking. */
  /* Reset handler name                    Address Name           Description */
  &MCU_init_reset,                      /* 0xFFFA  ivVcop         unused by PE */
  &MCU_init_reset,                      /* 0xFFFC  ivVclkmon      unused by PE */
  &MCU_init_reset                       /* 0xFFFE  ivVreset       used by PE */
};



#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVportp
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVportp(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVportp */


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVatd0compare
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVatd0compare(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVatd0compare */


#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
** ===================================================================
**     Interrupt handler : isrVpit0
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVpit0(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVpit0 */

/* END MCUinit */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.02 [04.44]
**     for the Freescale HCS12X series of microcontrollers.
**
** ###################################################################
*/
